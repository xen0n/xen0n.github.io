<!doctype html><html lang=zh-cmn-hans-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker 与 systemd-networkd 之间不得不说的故事 | write(2)</title><meta name=keywords content><meta name=description content="tl;dr 如果你使用 systemd-networkd 管理你的网络界面, 又把这台机器作为 Docker 容器宿主的话, 那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 /etc/systemd/network/your.network 配置里明确告诉"><meta name=author content="WÁNG &#34;xen0n&#34; Xuěruì"><link rel=canonical href=https://blog.xen0n.name/posts/tinkering/docker-systemd-networkd-frustrations/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.xen0n.name/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.xen0n.name/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.xen0n.name/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.xen0n.name/apple-touch-icon.png><link rel=mask-icon href=https://blog.xen0n.name/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cmn-hans-cn href=https://blog.xen0n.name/posts/tinkering/docker-systemd-networkd-frustrations/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Docker 与 systemd-networkd 之间不得不说的故事"><meta property="og:description" content="tl;dr 如果你使用 systemd-networkd 管理你的网络界面, 又把这台机器作为 Docker 容器宿主的话, 那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 /etc/systemd/network/your.network 配置里明确告诉"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xen0n.name/posts/tinkering/docker-systemd-networkd-frustrations/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-11-05T15:45:00+08:00"><meta property="article:modified_time" content="2015-11-05T15:45:00+08:00"><meta property="og:site_name" content="write(2)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 与 systemd-networkd 之间不得不说的故事"><meta name=twitter:description content="tl;dr 如果你使用 systemd-networkd 管理你的网络界面, 又把这台机器作为 Docker 容器宿主的话, 那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 /etc/systemd/network/your.network 配置里明确告诉"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.xen0n.name/posts/"},{"@type":"ListItem","position":2,"name":"Docker 与 systemd-networkd 之间不得不说的故事","item":"https://blog.xen0n.name/posts/tinkering/docker-systemd-networkd-frustrations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker 与 systemd-networkd 之间不得不说的故事","name":"Docker 与 systemd-networkd 之间不得不说的故事","description":"tl;dr 如果你使用 systemd-networkd 管理你的网络界面, 又把这台机器作为 Docker 容器宿主的话, 那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 /etc/systemd/network/your.network 配置里明确告诉","keywords":[],"articleBody":"tl;dr 如果你使用 systemd-networkd 管理你的网络界面, 又把这台机器作为 Docker 容器宿主的话, 那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 /etc/systemd/network/your.network 配置里明确告诉 systemd-networkd 开启报文转发:\n# ... [Network] # ... IPForward=yes 并不愉快的经历 我有一台打算做 Docker 容器宿主的服务器, 然而部署完成不久就发现了一个严重问题 – 容器不能访问外网! 好吧实际上还是可以的… 刚开机就启动的 Docker 容器可以联网, 过一会启动的容器也能, 但再过一会就不行了; 故障时间也不一定, 有时候开机几分钟就断网了, 有时候能撑半个小时, 完全没有规律. 就这样闲置了半年之久!\n最近因为做项目, 又有了用容器的需求, 就想着回来调试一下吧; 更新了所有软件到最新版本, 也升级了内核到最新的 Gentoo Hardened 4.2.5 版本, 然而情况并没有变化. 因为刚刚闲了下来, 就彻彻底底地解决这个问题好了, 于是我打开了内核源码 ;-)\n正常的流量 之前就在机器上抓过一次包, 想看看为什么容器没有收到响应. 因为断网的原因是多种多样的, 可能是报文没有出 docker0 界面, 报文没有上到物理界面, 报文没有正确被 NAT 回 Docker 内网地址, 还可能是其他更神奇的原因. 我在容器里 ping 宿主的网关和 DNS 服务器, 在宿主上抓包, 然而看到结果之后我几乎疯掉了…\n物理界面上有完整的 ICMP Ping 请求和响应包, 然而 docker0 上的响应被吃掉了!\n我又通过拼手速, 设法抓到了断网一瞬间前后的网络流量, 仍然没有什么问题; 在某个时间点过后, 响应包就是消失了, 完全不讲道理. 我觉得问题可能出在 Linux 内核本身了.\n仍然正常的 iptables Docker 默认的容器联网方式是桥接网络, 就是:\nDocker 启动时初始化一个网桥 docker0, 设置 iptables 让预先配置的 Docker 网段能 NAT 到外网 容器启动时, 首先创建一对 vethXXXXXX 虚拟界面, 一端塞进容器的 netns 里, 一端留在宿主 然后把宿主一侧的 veth 界面接入 docker0 如果有设置端口映射的话, 就为对应的容器 IP 和端口设置 MASQUERADE 和 DNAT 具体情况各位可以自行在跑 Docker 的机器上看一看 iptables -nvL 和 iptables -t nat -nvL 的输出, 不过应该区别不大.\n因为丢包的话首先就是考虑 iptables 是不是把包给 DROP 了, 我显然也是检查了一下, 然而 DROP 一次都没有出现… (因为服务器托管在学校网络中心, 我暂时没有单独设置防火墙)\n这不科学, 因此我做了这个操作给所有 ICMP 包启用了跟踪:\n# 首先需要加载 xt_LOG 模块, 这样 TRACE 才有效, 实际上 modprobe xt_LOG 就行了 # 然而我直接添加了一条规则, 效果一样 iptables -t nat -I PREROUTING 1 -p icmp -j LOG iptables -t raw -A PREROUTING -p icmp -j TRACE iptables -t raw -A OUTPUT -p icmp -j TRACE 继续拼手速打出了断网前后的 trace 对比 (把 IP 和硬件地址打码了, 并且改了 Docker 的网段):\n[ 118.520085] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520091] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520097] TRACE: mangle:FORWARD:policy:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520101] TRACE: filter:FORWARD:rule:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520105] TRACE: filter:DOCKER:return:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520109] TRACE: filter:FORWARD:rule:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 [ 118.520112] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=docker0 SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64 和\n[ 275.429990] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60797 PROTO=ICMP TYPE=0 CODE=0 ID=39 SEQ=2 [ 275.431901] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60797 PROTO=ICMP TYPE=0 CODE=0 ID=39 SEQ=2 噫… 断在了 mangle 表的 PREROUTING 和 FORWARD 两条链之间. iptables -t mangle -nL…\nChain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination 啊… (掩面)\n完全正常的 iptables 和 IPv4 路由 我编译了很多次内核, 打出更多的调试信息, 到意识到真正问题为止我做了如下的改动:\ndiff -ur a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c --- a/net/ipv4/ip_input.c\t2015-10-31 17:10:54.000000000 +0800 +++ b/net/ipv4/ip_input.c\t2015-11-05 10:48:11.713066532 +0800 @@ -341,6 +341,8 @@ if (!skb_dst(skb)) { int err = ip_route_input_noref(skb, iph-\u003edaddr, iph-\u003esaddr, iph-\u003etos, skb-\u003edev); +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_rcv_finish: ip_route_noref=%d\\n\", err); if (unlikely(err)) { if (err == -EXDEV) NET_INC_STATS_BH(dev_net(skb-\u003edev), @@ -349,6 +351,9 @@ } } +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_rcv_finish: survived routing\\n\"); + #ifdef CONFIG_IP_ROUTE_CLASSID if (unlikely(skb_dst(skb)-\u003etclassid)) { struct ip_rt_acct *st = this_cpu_ptr(ip_rt_acct); @@ -374,6 +379,9 @@ return dst_input(skb); drop: +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_rcv_finish: whoops\\n\"); + kfree_skb(skb); return NET_RX_DROP; } diff -ur a/net/ipv4/netfilter/iptable_mangle.c b/net/ipv4/netfilter/iptable_mangle.c --- a/net/ipv4/netfilter/iptable_mangle.c\t2015-08-31 02:34:09.000000000 +0800 +++ b/net/ipv4/netfilter/iptable_mangle.c\t2015-11-05 10:48:11.692066533 +0800 @@ -61,6 +61,8 @@ ret = ipt_do_table(skb, NF_INET_LOCAL_OUT, state, dev_net(out)-\u003eipv4.iptable_mangle); +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ipt_mangle_out: ipt_do_table=%d\\n\", ret); /* Reroute for ANY change. */ if (ret != NF_DROP \u0026\u0026 ret != NF_STOLEN) { iph = ip_hdr(skb); @@ -70,6 +72,8 @@ skb-\u003emark != mark || iph-\u003etos != tos) { err = ip_route_me_harder(skb, RTN_UNSPEC); +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ipt_mangle_out: ip_route_me_harder=%d\\n\", err); if (err \u003c 0) ret = NF_DROP_ERR(err); } @@ -84,14 +88,28 @@ struct sk_buff *skb, const struct nf_hook_state *state) { -\tif (ops-\u003ehooknum == NF_INET_LOCAL_OUT) -\treturn ipt_mangle_out(skb, state); -\tif (ops-\u003ehooknum == NF_INET_POST_ROUTING) -\treturn ipt_do_table(skb, ops-\u003ehooknum, state, +\tint phase; +\tunsigned int ret; +\tif (ops-\u003ehooknum == NF_INET_LOCAL_OUT) { +\tphase = 0; +\tret = ipt_mangle_out(skb, state); +\tgoto out; +\t} +\tif (ops-\u003ehooknum == NF_INET_POST_ROUTING) { +\tphase = 1; +\tret = ipt_do_table(skb, ops-\u003ehooknum, state, dev_net(state-\u003eout)-\u003eipv4.iptable_mangle); +\tgoto out; +\t} /* PREROUTING/INPUT/FORWARD: */ -\treturn ipt_do_table(skb, ops-\u003ehooknum, state, +\tphase = 2; +\tret = ipt_do_table(skb, ops-\u003ehooknum, state, dev_net(state-\u003ein)-\u003eipv4.iptable_mangle); + +\tout: +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"iptable_mangle_hook: phase=%d ret=%u\\n\", phase, ret); +\treturn ret; } static struct nf_hook_ops *mangle_ops __read_mostly; diff -ur a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c --- a/net/ipv4/netfilter/ip_tables.c\t2015-10-31 17:10:54.000000000 +0800 +++ b/net/ipv4/netfilter/ip_tables.c\t2015-11-05 10:48:11.690066533 +0800 @@ -429,6 +429,9 @@ xt_write_recseq_end(addend); local_bh_enable(); +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"TRACE: acpar.hotdrop=%d verdict=%d\\n\", acpar.hotdrop, verdict); + #ifdef DEBUG_ALLOW_ALL return NF_ACCEPT; #else 然后重启进修改过的内核, 给 ICMP 包启用跟踪, 看到了这样的结果:\n[ 89.207465] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.209365] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 89.210310] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.212222] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 89.213162] iptable_mangle_hook: phase=2 ret=1 [ 89.214087] IPv4: ip_rcv_finish: ip_route_noref=0 [ 89.214994] IPv4: ip_rcv_finish: survived routing [ 89.215891] TRACE: mangle:FORWARD:policy:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.217741] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 89.218679] iptable_mangle_hook: phase=2 ret=1 [ 89.219605] TRACE: filter:FORWARD:rule:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.221493] TRACE: filter:DOCKER:return:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.223402] TRACE: filter:FORWARD:rule:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.225315] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 89.226257] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=docker0 SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25 [ 89.228144] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 89.229073] iptable_mangle_hook: phase=1 ret=1 和\n[ 90.209849] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47321 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=26 [ 90.212000] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 90.212974] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47321 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=26 [ 90.214932] ip_tables: TRACE: acpar.hotdrop=0 verdict=1 [ 90.215900] iptable_mangle_hook: phase=2 ret=1 [ 90.216854] IPv4: ip_rcv_finish: ip_route_noref=0 [ 90.217795] IPv4: ip_rcv_finish: survived routing 我擦泪… 这路由结果明明是对的… iptables 也正确放行了… 那为何没有 forward 呢?\n最后知道真相的我眼泪掉下来 diff -ur a/net/ipv4/route.c b/net/ipv4/route.c --- a/net/ipv4/route.c\t2015-10-31 17:10:54.000000000 +0800 +++ b/net/ipv4/route.c\t2015-11-05 10:48:11.713066532 +0800 @@ -1717,11 +1717,15 @@ fl4.daddr = daddr; fl4.saddr = saddr; err = fib_lookup(net, \u0026fl4, \u0026res, 0); +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_route_input_slow: fib_lookup err=%d IN_DEV_FORWARD(in_dev)=%d\\n\", err, IN_DEV_FORWARD(in_dev)); if (err != 0) { if (!IN_DEV_FORWARD(in_dev)) err = -EHOSTUNREACH; goto no_route; } +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_route_input_slow: res.type=%d\\n\", res.type); if (res.type == RTN_BROADCAST) goto brd_input; @@ -1741,6 +1745,9 @@ if (res.type != RTN_UNICAST) goto martian_destination; +\tif (unlikely(skb-\u003enf_trace)) +\tpr_info(\"ip_route_input_slow: passed!\\n\"); + err = ip_mkroute_input(skb, \u0026res, \u0026fl4, in_dev, daddr, saddr, tos); out:\treturn err; 其实在写完这个更改之后我已经意识到问题了, 因为我中间搜索了很多内容, 其中包括观察到 /proc/net/snmp 里 InAddrErrors 会随着丢掉的包数量增加, 而这个量对应的内核状态 IPSTATS_MIB_INADDRERRORS 只在一个地方增加:\n/* net/ipv4/route.c */ static int ip_error(struct sk_buff *skb) { struct in_device *in_dev = __in_dev_get_rcu(skb-\u003edev); struct rtable *rt = skb_rtable(skb); struct inet_peer *peer; unsigned long now; struct net *net; bool send; int code; /* IP on this device is disabled. */ if (!in_dev) goto out; net = dev_net(rt-\u003edst.dev); if (!IN_DEV_FORWARD(in_dev)) { switch (rt-\u003edst.error) { case EHOSTUNREACH: IP_INC_STATS_BH(net, IPSTATS_MIB_INADDRERRORS); break; case ENETUNREACH: IP_INC_STATS_BH(net, IPSTATS_MIB_INNOROUTES); break; } goto out; } /* ... */ out: kfree_skb(skb); return 0; } 嗯… 这说明 IN_DEV_FORWARD(in_dev) 必然为假, 就是说 /proc/sys/net/ipv4/conf/xxx/forwarding 居然不是 1? 我之前不相信这个可能性, 所以打了很多日志, 但是现在看来真相只有一个了! 因为调试的时候观察到只要一运行 tcpdump 容器就会断网, 我就重启机器简单测试了一下:\n# cat /proc/sys/net/ipv4/conf/eno1/forwarding 1 # tcpdump -i docker0 -s 65535 -w 111.pcap (...) ^C # cat /proc/sys/net/ipv4/conf/eno1/forwarding 0 给我块豆腐… 那除了内核, 还会有谁关心网络界面的参数设置呢? 很容易就能联想到 systemd-networkd 了… 果然在 man systemd.network 里对于 IPForward 参数有说明:\nNote: unless this option is turned on, or set to \"kernel\", no IP forwarding is done on this interface, even if this is globally turned on in the kernel, with the net.ipv4.ip_forward, net.ipv4.conf.all.forwarding, and net.ipv6.conf.all.forwarding sysctl options.\n(格式是我加上的, 方便阅读)\n于是做了开头的 one-line fix, 重启, 问题消失. 前后花掉了 3 天时间思考和调试. 看起来生产环境用上 systemd-networkd 的人不多啊… 否则怎么可能至今没有文章介绍这个坑呢?\n追记: 不定期断网的原因追踪 解决了断网问题之后, 我继续思考了一下为什么 systemd-networkd 会不定期跟内核同步. 稍微熟悉一点 systemd 的各位都知道, systemd 严重依赖事件驱动, 那么原因应该就是有事件触发了 systemd-networkd 的状态同步代码. 在 systemd 源码里简单 grep 了一圈, 果然: link_set_ipv4_forward (和另一个负责 IPv6 的函数) 只会被 link_configure 调用, 又只会被 link_initialized_and_synced 调用, 又只会被 link_initialized 调用, 这个函数不是 static 的所以应该有别的地方去调用它了, 很可能是个 uevent 监听循环. 因为比起研究 systemd 我还有更有意思的事情要做 (比如好好折腾一下 Docker 之类的), 就没有继续挖掘下去了, 而是写了这篇分析文章. 希望对各位都有帮助!\n","wordCount":"2764","inLanguage":"zh-cmn-hans-cn","datePublished":"2015-11-05T15:45:00+08:00","dateModified":"2015-11-05T15:45:00+08:00","author":[{"@type":"Person","name":"WÁNG \"xen0n\" Xuěruì"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.xen0n.name/posts/tinkering/docker-systemd-networkd-frustrations/"},"publisher":{"@type":"Organization","name":"write(2)","logo":{"@type":"ImageObject","url":"https://blog.xen0n.name/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.xen0n.name/ accesskey=h title="write(2) (Alt + H)">write(2)</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.xen0n.name/en/ title="English (US)" aria-label=:us:>🇺🇸</a></li></ul></span></div><ul id=menu><li><a href=https://blog.xen0n.name/archives title=所有文章><span>所有文章</span></a></li><li><a href=https://blog.xen0n.name/%E6%96%87%E7%AB%A0%E7%B1%BB%E5%88%AB title=文章类别><span>文章类别</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.xen0n.name/>主页</a>&nbsp;»&nbsp;<a href=https://blog.xen0n.name/posts/>Posts</a></div><h1 class=post-title>Docker 与 systemd-networkd 之间不得不说的故事</h1><div class=post-meta><span title='2015-11-05 15:45:00 +0800 +0800'>2015/11/05</span>&nbsp;·&nbsp;预计阅读时间: 6 分钟&nbsp;·&nbsp;WÁNG "xen0n" Xuěruì</div></header><div class=post-content><h2 id=tldr>tl;dr<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>如果你<strong>使用 systemd-networkd 管理你的网络界面</strong>, 又把这台机器作为 <strong>Docker 容器宿主</strong>的话,
那你很可能会发现你的容器过一段时间就会不能访问外网. 你需要在 <code>/etc/systemd/network/your.network</code>
配置里明确告诉 systemd-networkd 开启报文转发:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Network]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>IPForward</span><span style=color:#f92672>=</span><span style=color:#e6db74>yes</span>
</span></span></code></pre></div><h2 id=并不愉快的经历>并不愉快的经历<a hidden class=anchor aria-hidden=true href=#并不愉快的经历>#</a></h2><p>我有一台打算做 Docker 容器宿主的服务器, 然而部署完成不久就发现了一个严重问题 &ndash;
容器不能访问外网! 好吧实际上还是可以的&mldr; 刚开机就启动的 Docker 容器可以联网,
过一会启动的容器也能, 但再过一会就不行了; 故障时间也不一定, 有时候开机几分钟就断网了,
有时候能撑半个小时, 完全没有规律. 就这样闲置了半年之久!</p><p>最近因为做项目, 又有了用容器的需求, 就想着回来调试一下吧; 更新了所有软件到最新版本,
也升级了内核到最新的 Gentoo Hardened 4.2.5 版本, 然而情况并没有变化.
因为刚刚闲了下来, 就彻彻底底地解决这个问题好了, 于是我打开了内核源码 ;-)</p><h2 id=正常的流量>正常的流量<a hidden class=anchor aria-hidden=true href=#正常的流量>#</a></h2><p>之前就在机器上抓过一次包, 想看看为什么容器没有收到响应. 因为断网的原因是多种多样的,
可能是报文没有出 <code>docker0</code> 界面, 报文没有上到物理界面, 报文没有正确被 NAT 回
Docker 内网地址, 还可能是其他更神奇的原因. 我在容器里 ping 宿主的网关和 DNS
服务器, 在宿主上抓包, 然而看到结果之后我几乎疯掉了&mldr;</p><p>物理界面上有完整的 ICMP Ping 请求和响应包, 然而 <code>docker0</code> 上的响应被吃掉了!</p><p>我又通过拼手速, 设法抓到了断网一瞬间前后的网络流量, 仍然没有什么问题;
在某个时间点过后, 响应包就是消失了, 完全不讲道理. 我觉得问题可能出在 Linux 内核本身了.</p><h2 id=仍然正常的-iptables>仍然正常的 iptables<a hidden class=anchor aria-hidden=true href=#仍然正常的-iptables>#</a></h2><p>Docker 默认的容器联网方式是桥接网络, 就是:</p><ul><li>Docker 启动时初始化一个网桥 <code>docker0</code>, 设置 iptables 让预先配置的 Docker 网段能 NAT 到外网</li><li>容器启动时, 首先创建一对 <code>vethXXXXXX</code> 虚拟界面, 一端塞进容器的 netns 里, 一端留在宿主</li><li>然后把宿主一侧的 veth 界面接入 <code>docker0</code></li><li>如果有设置端口映射的话, 就为对应的容器 IP 和端口设置 <code>MASQUERADE</code> 和 <code>DNAT</code></li></ul><p>具体情况各位可以自行在跑 Docker 的机器上看一看 <code>iptables -nvL</code> 和 <code>iptables -t nat -nvL</code>
的输出, 不过应该区别不大.</p><p>因为丢包的话首先就是考虑 iptables 是不是把包给 <code>DROP</code> 了, 我显然也是检查了一下,
然而 <code>DROP</code> 一次都没有出现&mldr; (因为服务器托管在学校网络中心, 我暂时没有单独设置防火墙)</p><p>这不科学, 因此我做了这个操作给所有 ICMP 包启用了跟踪:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 首先需要加载 xt_LOG 模块, 这样 TRACE 才有效, 实际上 modprobe xt_LOG 就行了</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 然而我直接添加了一条规则, 效果一样</span>
</span></span><span style=display:flex><span>iptables -t nat -I PREROUTING <span style=color:#ae81ff>1</span> -p icmp -j LOG
</span></span><span style=display:flex><span>iptables -t raw -A PREROUTING -p icmp -j TRACE
</span></span><span style=display:flex><span>iptables -t raw -A OUTPUT -p icmp -j TRACE
</span></span></code></pre></div><p>继续拼手速打出了断网前后的 trace 对比 (把 IP 和硬件地址打码了, 并且改了 Docker 的网段):</p><pre tabindex=0><code>[  118.520085] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520091] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520097] TRACE: mangle:FORWARD:policy:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520101] TRACE: filter:FORWARD:rule:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520105] TRACE: filter:DOCKER:return:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520109] TRACE: filter:FORWARD:rule:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
[  118.520112] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=docker0 SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=60758 PROTO=ICMP TYPE=0 CODE=0 ID=35 SEQ=64
</code></pre><p>和</p><pre tabindex=0><code>[  275.429990] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60797 PROTO=ICMP TYPE=0 CODE=0 ID=39 SEQ=2
[  275.431901] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60797 PROTO=ICMP TYPE=0 CODE=0 ID=39 SEQ=2
</code></pre><p>噫&mldr; 断在了 <code>mangle</code> 表的 <code>PREROUTING</code> 和 <code>FORWARD</code> 两条链之间. <code>iptables -t mangle -nL</code>&mldr;</p><pre tabindex=0><code>Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
</code></pre><p>啊&mldr; (掩面)</p><h2 id=完全正常的-iptables-和-ipv4-路由>完全正常的 iptables 和 IPv4 路由<a hidden class=anchor aria-hidden=true href=#完全正常的-iptables-和-ipv4-路由>#</a></h2><p>我编译了很多次内核, 打出更多的调试信息, 到意识到真正问题为止我做了如下的改动:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff -ur a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/net/ipv4/ip_input.c	2015-10-31 17:10:54.000000000 +0800
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/net/ipv4/ip_input.c	2015-11-05 10:48:11.713066532 +0800
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -341,6 +341,8 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	if (!skb_dst(skb)) {
</span></span><span style=display:flex><span> 		int err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,
</span></span><span style=display:flex><span> 					       iph-&gt;tos, skb-&gt;dev);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+		if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+			pr_info(&#34;ip_rcv_finish: ip_route_noref=%d\n&#34;, err);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 		if (unlikely(err)) {
</span></span><span style=display:flex><span> 			if (err == -EXDEV)
</span></span><span style=display:flex><span> 				NET_INC_STATS_BH(dev_net(skb-&gt;dev),
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -349,6 +351,9 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 		}
</span></span><span style=display:flex><span> 	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ip_rcv_finish: survived routing\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> #ifdef CONFIG_IP_ROUTE_CLASSID
</span></span><span style=display:flex><span> 	if (unlikely(skb_dst(skb)-&gt;tclassid)) {
</span></span><span style=display:flex><span> 		struct ip_rt_acct *st = this_cpu_ptr(ip_rt_acct);
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -374,6 +379,9 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	return dst_input(skb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> drop:
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ip_rcv_finish: whoops\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	kfree_skb(skb);
</span></span><span style=display:flex><span> 	return NET_RX_DROP;
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>diff -ur a/net/ipv4/netfilter/iptable_mangle.c b/net/ipv4/netfilter/iptable_mangle.c
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/net/ipv4/netfilter/iptable_mangle.c	2015-08-31 02:34:09.000000000 +0800
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/net/ipv4/netfilter/iptable_mangle.c	2015-11-05 10:48:11.692066533 +0800
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -61,6 +61,8 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> 	ret = ipt_do_table(skb, NF_INET_LOCAL_OUT, state,
</span></span><span style=display:flex><span> 			   dev_net(out)-&gt;ipv4.iptable_mangle);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ipt_mangle_out: ipt_do_table=%d\n&#34;, ret);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	/* Reroute for ANY change. */
</span></span><span style=display:flex><span> 	if (ret != NF_DROP &amp;&amp; ret != NF_STOLEN) {
</span></span><span style=display:flex><span> 		iph = ip_hdr(skb);
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -70,6 +72,8 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 		    skb-&gt;mark != mark ||
</span></span><span style=display:flex><span> 		    iph-&gt;tos != tos) {
</span></span><span style=display:flex><span> 			err = ip_route_me_harder(skb, RTN_UNSPEC);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+			if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+				pr_info(&#34;ipt_mangle_out: ip_route_me_harder=%d\n&#34;, err);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 			if (err &lt; 0)
</span></span><span style=display:flex><span> 				ret = NF_DROP_ERR(err);
</span></span><span style=display:flex><span> 		}
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -84,14 +88,28 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 		     struct sk_buff *skb,
</span></span><span style=display:flex><span> 		     const struct nf_hook_state *state)
</span></span><span style=display:flex><span> {
</span></span><span style=display:flex><span><span style=color:#f92672>-	if (ops-&gt;hooknum == NF_INET_LOCAL_OUT)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-		return ipt_mangle_out(skb, state);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-	if (ops-&gt;hooknum == NF_INET_POST_ROUTING)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-		return ipt_do_table(skb, ops-&gt;hooknum, state,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+	int phase;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	unsigned int ret;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (ops-&gt;hooknum == NF_INET_LOCAL_OUT) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		phase = 0;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		ret = ipt_mangle_out(skb, state);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		goto out;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (ops-&gt;hooknum == NF_INET_POST_ROUTING) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		phase = 1;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		ret = ipt_do_table(skb, ops-&gt;hooknum, state,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 				    dev_net(state-&gt;out)-&gt;ipv4.iptable_mangle);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+		goto out;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	/* PREROUTING/INPUT/FORWARD: */
</span></span><span style=display:flex><span><span style=color:#f92672>-	return ipt_do_table(skb, ops-&gt;hooknum, state,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+	phase = 2;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	ret = ipt_do_table(skb, ops-&gt;hooknum, state,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 			    dev_net(state-&gt;in)-&gt;ipv4.iptable_mangle);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	out:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;iptable_mangle_hook: phase=%d ret=%u\n&#34;, phase, ret);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	return ret;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> static struct nf_hook_ops *mangle_ops __read_mostly;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>diff -ur a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/net/ipv4/netfilter/ip_tables.c	2015-10-31 17:10:54.000000000 +0800
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/net/ipv4/netfilter/ip_tables.c	2015-11-05 10:48:11.690066533 +0800
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -429,6 +429,9 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	xt_write_recseq_end(addend);
</span></span><span style=display:flex><span>  	local_bh_enable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;TRACE: acpar.hotdrop=%d verdict=%d\n&#34;, acpar.hotdrop, verdict);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> #ifdef DEBUG_ALLOW_ALL
</span></span><span style=display:flex><span> 	return NF_ACCEPT;
</span></span><span style=display:flex><span> #else
</span></span></code></pre></div><p>然后重启进修改过的内核, 给 ICMP 包启用跟踪, 看到了这样的结果:</p><pre tabindex=0><code>[   89.207465] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.209365] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   89.210310] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.212222] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   89.213162] iptable_mangle_hook: phase=2 ret=1
[   89.214087] IPv4: ip_rcv_finish: ip_route_noref=0
[   89.214994] IPv4: ip_rcv_finish: survived routing
[   89.215891] TRACE: mangle:FORWARD:policy:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.217741] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   89.218679] iptable_mangle_hook: phase=2 ret=1
[   89.219605] TRACE: filter:FORWARD:rule:1 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.221493] TRACE: filter:DOCKER:return:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.223402] TRACE: filter:FORWARD:rule:2 IN=eno1 OUT=docker0 MAC=xxx SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.225315] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   89.226257] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=docker0 SRC=xxx DST=10.111.1.2 LEN=84 TOS=0x00 PREC=0x00 TTL=254 ID=47320 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=25
[   89.228144] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   89.229073] iptable_mangle_hook: phase=1 ret=1
</code></pre><p>和</p><pre tabindex=0><code>[   90.209849] TRACE: raw:PREROUTING:policy:2 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47321 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=26
[   90.212000] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   90.212974] TRACE: mangle:PREROUTING:policy:1 IN=eno1 OUT= MAC=xxx SRC=xxx DST=xxx LEN=84 TOS=0x00 PREC=0x00 TTL=255 ID=47321 DF PROTO=ICMP TYPE=0 CODE=0 ID=34 SEQ=26
[   90.214932] ip_tables: TRACE: acpar.hotdrop=0 verdict=1
[   90.215900] iptable_mangle_hook: phase=2 ret=1
[   90.216854] IPv4: ip_rcv_finish: ip_route_noref=0
[   90.217795] IPv4: ip_rcv_finish: survived routing
</code></pre><p>我擦泪&mldr; 这路由结果明明是对的&mldr; iptables 也正确放行了&mldr; 那为何没有 forward 呢?</p><h2 id=最后知道真相的我眼泪掉下来>最后知道真相的我眼泪掉下来<a hidden class=anchor aria-hidden=true href=#最后知道真相的我眼泪掉下来>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff -ur a/net/ipv4/route.c b/net/ipv4/route.c
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/net/ipv4/route.c	2015-10-31 17:10:54.000000000 +0800
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/net/ipv4/route.c	2015-11-05 10:48:11.713066532 +0800
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -1717,11 +1717,15 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	fl4.daddr = daddr;
</span></span><span style=display:flex><span> 	fl4.saddr = saddr;
</span></span><span style=display:flex><span> 	err = fib_lookup(net, &amp;fl4, &amp;res, 0);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ip_route_input_slow: fib_lookup err=%d IN_DEV_FORWARD(in_dev)=%d\n&#34;, err, IN_DEV_FORWARD(in_dev));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	if (err != 0) {
</span></span><span style=display:flex><span> 		if (!IN_DEV_FORWARD(in_dev))
</span></span><span style=display:flex><span> 			err = -EHOSTUNREACH;
</span></span><span style=display:flex><span> 		goto no_route;
</span></span><span style=display:flex><span> 	}
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ip_route_input_slow: res.type=%d\n&#34;, res.type);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span> 	if (res.type == RTN_BROADCAST)
</span></span><span style=display:flex><span> 		goto brd_input;
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1741,6 +1745,9 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	if (res.type != RTN_UNICAST)
</span></span><span style=display:flex><span> 		goto martian_destination;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(skb-&gt;nf_trace))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_info(&#34;ip_route_input_slow: passed!\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	err = ip_mkroute_input(skb, &amp;res, &amp;fl4, in_dev, daddr, saddr, tos);
</span></span><span style=display:flex><span> out:	return err;
</span></span></code></pre></div><p>其实在写完这个更改之后我已经意识到问题了, 因为我<a href=http://serverfault.com/q/653636>中间</a><a href=https://lists.netfilter.org/pipermail/netfilter/2005-November/063703.html>搜索了</a><a href=https://github.com/docker/docker/issues/15172>很多</a><a href=https://github.com/docker/docker/issues/13381>内容</a>, 其中包括观察到
<code>/proc/net/snmp</code> 里 <code>InAddrErrors</code> 会随着丢掉的包数量增加, 而这个量对应的内核状态
<code>IPSTATS_MIB_INADDRERRORS</code> 只在一个地方增加:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* net/ipv4/route.c */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ip_error</span>(<span style=color:#66d9ef>struct</span> sk_buff <span style=color:#f92672>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> in_device <span style=color:#f92672>*</span>in_dev <span style=color:#f92672>=</span> __in_dev_get_rcu(skb<span style=color:#f92672>-&gt;</span>dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> rtable <span style=color:#f92672>*</span>rt <span style=color:#f92672>=</span> skb_rtable(skb);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> inet_peer <span style=color:#f92672>*</span>peer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> now;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> net <span style=color:#f92672>*</span>net;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> send;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> code;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* IP on this device is disabled. */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>in_dev)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        net <span style=color:#f92672>=</span> dev_net(rt<span style=color:#f92672>-&gt;</span>dst.dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>IN_DEV_FORWARD(in_dev)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>switch</span> (rt<span style=color:#f92672>-&gt;</span>dst.error) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> EHOSTUNREACH:
</span></span><span style=display:flex><span>                        IP_INC_STATS_BH(net, IPSTATS_MIB_INADDRERRORS);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> ENETUNREACH:
</span></span><span style=display:flex><span>                        IP_INC_STATS_BH(net, IPSTATS_MIB_INNOROUTES);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> out;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out:    kfree_skb(skb);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>嗯&mldr; 这说明 <code>IN_DEV_FORWARD(in_dev)</code> 必然为假, 就是说 <code>/proc/sys/net/ipv4/conf/xxx/forwarding</code>
居然不是 <code>1</code>? 我之前不相信这个可能性, 所以打了很多日志, 但是现在看来真相只有一个了!
因为调试的时候观察到只要一运行 <code>tcpdump</code> 容器就会断网, 我就重启机器简单测试了一下:</p><pre tabindex=0><code># cat /proc/sys/net/ipv4/conf/eno1/forwarding
1
# tcpdump -i docker0 -s 65535 -w 111.pcap
(...)
^C
# cat /proc/sys/net/ipv4/conf/eno1/forwarding
0
</code></pre><p>给我块豆腐&mldr; 那除了内核, 还会有谁关心网络界面的参数设置呢? 很容易就能联想到
systemd-networkd 了&mldr; 果然在 <code>man systemd.network</code> 里对于 <code>IPForward</code> 参数有说明:</p><blockquote><p>Note: unless this option is turned on, or set to <code>"kernel"</code>, <strong>no IP forwarding
is done on this interface, even if this is globally turned on in the kernel</strong>,
with the <code>net.ipv4.ip_forward</code>, <code>net.ipv4.conf.all.forwarding</code>, and
<code>net.ipv6.conf.all.forwarding</code> sysctl options.</p></blockquote><p>(格式是我加上的, 方便阅读)</p><p>于是做了开头的 one-line fix, 重启, 问题消失. 前后花掉了 3 天时间思考和调试.
看起来生产环境用上 systemd-networkd 的人不多啊&mldr; 否则怎么可能至今没有文章介绍这个坑呢?</p><h2 id=追记-不定期断网的原因追踪>追记: 不定期断网的原因追踪<a hidden class=anchor aria-hidden=true href=#追记-不定期断网的原因追踪>#</a></h2><p>解决了断网问题之后, 我继续思考了一下为什么 systemd-networkd 会不定期跟内核同步.
稍微熟悉一点 systemd 的各位都知道, systemd 严重依赖事件驱动, 那么原因应该就是有事件触发了
systemd-networkd 的状态同步代码. 在 systemd 源码里简单 <code>grep</code> 了一圈, <a href=https://github.com/systemd/systemd/blob/master/src/network/networkd-link.c#L1802>果然</a>:
<code>link_set_ipv4_forward</code> (和另一个负责 IPv6 的函数) 只会被 <code>link_configure</code> 调用,
又只会被 <code>link_initialized_and_synced</code> 调用, 又只会被 <code>link_initialized</code> 调用,
这个函数不是 <code>static</code> 的所以应该有别的地方去调用它了, 很可能是个 uevent 监听循环.
因为比起研究 systemd 我还有更有意思的事情要做 (比如好好折腾一下 Docker 之类的),
就没有继续挖掘下去了, 而是写了这篇分析文章. 希望对各位都有帮助!</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.xen0n.name/posts/old/meizu-mx4-cm/cm-12.1-userdebug-7/><span class=title>« 上一页</span><br><span>CyanogenMod for 魅族 MX4: CM12.1 20160107 测试包发布</span></a>
<a class=next href=https://blog.xen0n.name/posts/old/meizu-mx4-cm/cm-12.1-userdebug-6/><span class=title>下一页 »</span><br><span>CyanogenMod for 魅族 MX4: CM12.1 20151022 测试包发布</span></a></nav></footer><script src=https://utteranc.es/client.js repo=xen0n/xen0n.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>© WANG Xuerui; 以 cc-by-nc-sa 4.0 授权</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>