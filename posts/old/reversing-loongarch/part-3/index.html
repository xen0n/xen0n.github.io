<!doctype html><html lang=zh-cmn-hans-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本 | write(2)</title><meta name=keywords content><meta name=description content="本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。 本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式"><meta name=author content="WÁNG &#34;xen0n&#34; Xuěruì"><link rel=canonical href=https://blog.xen0n.name/posts/old/reversing-loongarch/part-3/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.xen0n.name/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.xen0n.name/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.xen0n.name/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.xen0n.name/apple-touch-icon.png><link rel=mask-icon href=https://blog.xen0n.name/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cmn-hans-cn href=https://blog.xen0n.name/posts/old/reversing-loongarch/part-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本"><meta property="og:description" content="本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。 本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xen0n.name/posts/old/reversing-loongarch/part-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-21T12:04:00+08:00"><meta property="article:modified_time" content="2021-02-21T12:04:00+08:00"><meta property="og:site_name" content="write(2)"><meta name=twitter:card content="summary"><meta name=twitter:title content="《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本"><meta name=twitter:description content="本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。 本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.xen0n.name/posts/"},{"@type":"ListItem","position":2,"name":"《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本","item":"https://blog.xen0n.name/posts/old/reversing-loongarch/part-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本","name":"《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本","description":"本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。 本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式","keywords":[],"articleBody":" 本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。\n本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式帮助。\n本研究属于个人行为，与本人雇主或任何其他主体无关。\n上一回我们讲到，解包出来的二进制真的是 LoongArch 的 ELF 文件，接下来我们可以有两个方向：一是释读 LoongArch ELF 格式的特殊内容；二是直接动手，搞明白指令含义。\nELF 文件格式支持每个架构各自表达一些特定属性、tag、section。这么做也是合情合理，正如没有两片雪花完全相同，不同架构当然也有各自独特的属性。你不会看到 AMD64 的程序库声明自己不支持浮点指令，也不会看到 ARM 可执行文件包含 MIPS 格式的重定向记录。由于 ELF 格式本身就考虑了这部分需求，我们不需要先行了解任何 LoongArch 的信息，就可以搞明白很多东西——\n然而，实际操作中当然需要先弄懂指令集，才能真正把这些架构相关扩展整明白。例如你看到一个类型 3 的重定向，地址是 78f00，内容是 1a2b3c，你并不能直接知道它的含义是把“什么东西”写到“什么位置”。到底是把 1a2b3c 左移 10 位然后合并到 78f00 - 代码段基址 的指令字里？还是用 1a2b3c 先减去 78f00 构造一个 PC-relative 偏移量然后左移 6 位写入相同的地方？\n那我们还是先想办法把指令都提取出来再说吧！\n有一个工具叫 readelf，顾名思义，它 reads ELF files；你可以自己不带参数，或者带着 --help 运行一下，支持的功能挺多的。我们直接让他解析文件头：\n$ readelf -eW libpython2.7_d.so.1.0 ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: : 0x102 Version: 0x1 Entry point address: 0x52a10 Start of program headers: 64 (bytes into file) Start of section headers: 9896856 (bytes into file) Flags: 0x3 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 6 Size of section headers: 64 (bytes) Number of section headers: 34 Section header string table index: 33 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .note.gnu.build-id NOTE 0000000000000190 000190 000024 00 A 0 0 4 [ 2] .hash HASH 00000000000001b8 0001b8 002a88 04 A 4 0 8 [ 3] .gnu.hash GNU_HASH 0000000000002c40 002c40 002910 00 A 4 0 8 [ 4] .dynsym DYNSYM 0000000000005550 005550 00a038 18 A 5 7 8 [ 5] .dynstr STRTAB 000000000000f588 00f588 006f5c 00 A 0 0 1 [ 6] .gnu.version VERSYM 00000000000164e4 0164e4 000d5a 02 A 4 0 2 [ 7] .gnu.version_r VERNEED 0000000000017240 017240 000110 00 A 5 7 8 [ 8] .rela.dyn RELA 0000000000017350 017350 0386a0 18 A 4 0 8 [ 9] .rela.plt RELA 000000000004f9f0 04f9f0 001cc8 18 AI 4 19 8 [10] .plt PROGBITS 00000000000516c0 0516c0 001350 10 AX 0 0 16 [11] .text PROGBITS 0000000000052a10 052a10 25b058 00 AX 0 0 8 [12] .rodata PROGBITS 00000000002ada68 2ada68 04664d 00 A 0 0 8 [13] .eh_frame PROGBITS 00000000002f40b8 2f40b8 000004 00 A 0 0 4 [14] .init_array INIT_ARRAY 00000000002fbc88 2f7c88 000008 08 WA 0 0 8 [15] .fini_array FINI_ARRAY 00000000002fbc90 2f7c90 000008 08 WA 0 0 8 [16] .data.rel.ro PROGBITS 00000000002fbc98 2f7c98 000138 00 WA 0 0 8 [17] .dynamic DYNAMIC 00000000002fbdd0 2f7dd0 000230 10 WA 5 0 8 [18] .data PROGBITS 00000000002fc000 2f8000 10b790 00 WA 0 0 8 [19] .got.plt PROGBITS 0000000000407790 403790 0009a8 08 WA 0 0 8 [20] .got PROGBITS 0000000000408138 404138 000998 08 WA 0 0 8 [21] .sdata PROGBITS 0000000000408ad0 404ad0 000008 00 WA 0 0 8 [22] .bss NOBITS 0000000000408ad8 404ad8 023c00 00 WA 0 0 8 [23] .comment PROGBITS 0000000000000000 404ad8 000022 01 MS 0 0 1 [24] .debug_aranges PROGBITS 0000000000000000 404afa 001c00 00 0 0 1 [25] .debug_info PROGBITS 0000000000000000 4066fa 1f390b 00 0 0 1 [26] .debug_abbrev PROGBITS 0000000000000000 5fa005 01caf8 00 0 0 1 [27] .debug_line PROGBITS 0000000000000000 616afd 273a49 00 0 0 1 [28] .debug_frame PROGBITS 0000000000000000 88a548 05c2b8 00 0 0 8 [29] .debug_str PROGBITS 0000000000000000 8e6800 028332 01 MS 0 0 1 [30] .debug_ranges PROGBITS 0000000000000000 90eb32 0089c0 00 0 0 1 [31] .symtab SYMTAB 0000000000000000 9174f8 037380 18 32 7723 8 [32] .strtab STRTAB 0000000000000000 94e878 0219d8 00 0 0 1 [33] .shstrtab STRTAB 0000000000000000 970250 000142 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x000000 0x0000000000000000 0x0000000000000000 0x2f40bc 0x2f40bc R E 0x4000 LOAD 0x2f7c88 0x00000000002fbc88 0x00000000002fbc88 0x10ce50 0x130a50 RW 0x4000 DYNAMIC 0x2f7dd0 0x00000000002fbdd0 0x00000000002fbdd0 0x000230 0x000230 RW 0x8 NOTE 0x000190 0x0000000000000190 0x0000000000000190 0x000024 0x000024 R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x2f7c88 0x00000000002fbc88 0x00000000002fbc88 0x000378 0x000378 R 0x1 Section to Segment mapping: Segment Sections... 00 .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame 01 .init_array .fini_array .data.rel.ro .dynamic .data .got.plt .got .sdata .bss 02 .dynamic 03 .note.gnu.build-id 04 05 .init_array .fini_array .data.rel.ro .dynamic 由于 ELF 文件头本身就是平台无关的，使用任何架构的 readelf 都可以读，也不管你是原生工具链，还是交叉工具链。\n出于人类常识，移植一个全新的架构也犯不着把有的没的都全部改一遍，为了改而改，这样反而增加适配的工作量；所以 section 名字也都是熟悉的。那么代码段就还是叫 .text——文本！机器语言对机器而言就是“文本”。\n[Nr] Name Type Address Off Size ES Flg Lk Inf Al [11] .text PROGBITS 0000000000052a10 052a10 25b058 00 AX 0 0 8 这意思就是，这个库的代码段装载到从 0x52a10 开始的一块内存，内容从文件的第 0x52a10 字节（编号从 0 开始）起，长度有 0x25b058 字节。\n马上来看一下！还记得老胡那一页指令格式的 PPT 吗？所有指令都定长 32 位，跟大多数 RISC 架构都一样，那么——\nimport struct import sys # one little-endian 32-bit word INSN = struct.Struct('","wordCount":"1837","inLanguage":"zh-cmn-hans-cn","datePublished":"2021-02-21T12:04:00+08:00","dateModified":"2021-02-21T12:04:00+08:00","author":[{"@type":"Person","name":"WÁNG \"xen0n\" Xuěruì"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.xen0n.name/posts/old/reversing-loongarch/part-3/"},"publisher":{"@type":"Organization","name":"write(2)","logo":{"@type":"ImageObject","url":"https://blog.xen0n.name/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.xen0n.name/ accesskey=h title="write(2) (Alt + H)">write(2)</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.xen0n.name/en/ title="English (US)" aria-label=:us:>🇺🇸</a></li></ul></span></div><ul id=menu><li><a href=https://blog.xen0n.name/archives title=所有文章><span>所有文章</span></a></li><li><a href=https://blog.xen0n.name/%E6%96%87%E7%AB%A0%E7%B1%BB%E5%88%AB title=文章类别><span>文章类别</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.xen0n.name/>主页</a>&nbsp;»&nbsp;<a href=https://blog.xen0n.name/posts/>Posts</a></div><h1 class=post-title>《开局一个二进制，从零开始的 LoongArch 指令集推导》——第三回 阅读文本</h1><div class=post-meta><span title='2021-02-21 12:04:00 +0800 +0800'>2021/02/21</span>&nbsp;·&nbsp;预计阅读时间: 4 分钟&nbsp;·&nbsp;WÁNG "xen0n" Xuěruì</div></header><div class=post-content><blockquote><p>本 LoongArch 指令集研究工作在百度贴吧龙芯吧同步连载。</p><p>本研究中涉及的逆向工程仅出于学习、研究目的。本研究工作未得到任何龙芯、麒麟等软硬件厂商的任何形式帮助。</p><p>本研究属于个人行为，与本人雇主或任何其他主体无关。</p></blockquote><p>上一回我们讲到，解包出来的二进制真的是 LoongArch 的 ELF 文件，接下来我们可以有两个方向：一是释读 LoongArch ELF 格式的特殊内容；二是直接动手，搞明白指令含义。</p><p>ELF 文件格式支持每个架构各自表达一些特定属性、tag、section。这么做也是合情合理，正如没有两片雪花完全相同，不同架构当然也有各自独特的属性。你不会看到 AMD64 的程序库声明自己不支持浮点指令，也不会看到 ARM 可执行文件包含 MIPS 格式的重定向记录。由于 ELF 格式本身就考虑了这部分需求，我们不需要先行了解任何 LoongArch 的信息，就可以搞明白很多东西——</p><p>然而，实际操作中当然需要先弄懂指令集，才能真正把这些架构相关扩展整明白。例如你看到一个类型 3 的重定向，地址是 <code>78f00</code>，内容是 <code>1a2b3c</code>，你并不能直接知道它的含义是把“什么东西”写到“什么位置”。到底是把 <code>1a2b3c</code> 左移 10 位然后合并到 <code>78f00 - 代码段基址</code> 的指令字里？还是用 <code>1a2b3c</code> 先减去 <code>78f00</code> 构造一个 PC-relative 偏移量然后左移 6 位写入相同的地方？</p><p>那我们还是先想办法把指令都提取出来再说吧！</p><p>有一个工具叫 <code>readelf</code>，顾名思义，它 <code>reads ELF files</code>；你可以自己不带参数，或者带着 <code>--help</code> 运行一下，支持的功能挺多的。我们直接让他解析文件头：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ readelf -eW libpython2.7_d.so.1.0
</span></span><span style=display:flex><span>ELF Header:
</span></span><span style=display:flex><span>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
</span></span><span style=display:flex><span>  Class:                             ELF64
</span></span><span style=display:flex><span>  Data:                              2&#39;s complement, little endian
</span></span><span style=display:flex><span>  Version:                           1 (current)
</span></span><span style=display:flex><span>  OS/ABI:                            UNIX - System V
</span></span><span style=display:flex><span>  ABI Version:                       0
</span></span><span style=display:flex><span>  Type:                              DYN (Shared object file)
</span></span><span style=display:flex><span>  Machine:                           &lt;unknown&gt;: 0x102
</span></span><span style=display:flex><span>  Version:                           0x1
</span></span><span style=display:flex><span>  Entry point address:               0x52a10
</span></span><span style=display:flex><span>  Start of program headers:          64 (bytes into file)
</span></span><span style=display:flex><span>  Start of section headers:          9896856 (bytes into file)
</span></span><span style=display:flex><span>  Flags:                             0x3
</span></span><span style=display:flex><span>  Size of this header:               64 (bytes)
</span></span><span style=display:flex><span>  Size of program headers:           56 (bytes)
</span></span><span style=display:flex><span>  Number of program headers:         6
</span></span><span style=display:flex><span>  Size of section headers:           64 (bytes)
</span></span><span style=display:flex><span>  Number of section headers:         34
</span></span><span style=display:flex><span>  Section header string table index: 33
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Section Headers:
</span></span><span style=display:flex><span>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
</span></span><span style=display:flex><span>  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
</span></span><span style=display:flex><span>  [ 1] .note.gnu.build-id NOTE            0000000000000190 000190 000024 00   A  0   0  4
</span></span><span style=display:flex><span>  [ 2] .hash             HASH            00000000000001b8 0001b8 002a88 04   A  4   0  8
</span></span><span style=display:flex><span>  [ 3] .gnu.hash         GNU_HASH        0000000000002c40 002c40 002910 00   A  4   0  8
</span></span><span style=display:flex><span>  [ 4] .dynsym           DYNSYM          0000000000005550 005550 00a038 18   A  5   7  8
</span></span><span style=display:flex><span>  [ 5] .dynstr           STRTAB          000000000000f588 00f588 006f5c 00   A  0   0  1
</span></span><span style=display:flex><span>  [ 6] .gnu.version      VERSYM          00000000000164e4 0164e4 000d5a 02   A  4   0  2
</span></span><span style=display:flex><span>  [ 7] .gnu.version_r    VERNEED         0000000000017240 017240 000110 00   A  5   7  8
</span></span><span style=display:flex><span>  [ 8] .rela.dyn         RELA            0000000000017350 017350 0386a0 18   A  4   0  8
</span></span><span style=display:flex><span>  [ 9] .rela.plt         RELA            000000000004f9f0 04f9f0 001cc8 18  AI  4  19  8
</span></span><span style=display:flex><span>  [10] .plt              PROGBITS        00000000000516c0 0516c0 001350 10  AX  0   0 16
</span></span><span style=display:flex><span>  [11] .text             PROGBITS        0000000000052a10 052a10 25b058 00  AX  0   0  8
</span></span><span style=display:flex><span>  [12] .rodata           PROGBITS        00000000002ada68 2ada68 04664d 00   A  0   0  8
</span></span><span style=display:flex><span>  [13] .eh_frame         PROGBITS        00000000002f40b8 2f40b8 000004 00   A  0   0  4
</span></span><span style=display:flex><span>  [14] .init_array       INIT_ARRAY      00000000002fbc88 2f7c88 000008 08  WA  0   0  8
</span></span><span style=display:flex><span>  [15] .fini_array       FINI_ARRAY      00000000002fbc90 2f7c90 000008 08  WA  0   0  8
</span></span><span style=display:flex><span>  [16] .data.rel.ro      PROGBITS        00000000002fbc98 2f7c98 000138 00  WA  0   0  8
</span></span><span style=display:flex><span>  [17] .dynamic          DYNAMIC         00000000002fbdd0 2f7dd0 000230 10  WA  5   0  8
</span></span><span style=display:flex><span>  [18] .data             PROGBITS        00000000002fc000 2f8000 10b790 00  WA  0   0  8
</span></span><span style=display:flex><span>  [19] .got.plt          PROGBITS        0000000000407790 403790 0009a8 08  WA  0   0  8
</span></span><span style=display:flex><span>  [20] .got              PROGBITS        0000000000408138 404138 000998 08  WA  0   0  8
</span></span><span style=display:flex><span>  [21] .sdata            PROGBITS        0000000000408ad0 404ad0 000008 00  WA  0   0  8
</span></span><span style=display:flex><span>  [22] .bss              NOBITS          0000000000408ad8 404ad8 023c00 00  WA  0   0  8
</span></span><span style=display:flex><span>  [23] .comment          PROGBITS        0000000000000000 404ad8 000022 01  MS  0   0  1
</span></span><span style=display:flex><span>  [24] .debug_aranges    PROGBITS        0000000000000000 404afa 001c00 00      0   0  1
</span></span><span style=display:flex><span>  [25] .debug_info       PROGBITS        0000000000000000 4066fa 1f390b 00      0   0  1
</span></span><span style=display:flex><span>  [26] .debug_abbrev     PROGBITS        0000000000000000 5fa005 01caf8 00      0   0  1
</span></span><span style=display:flex><span>  [27] .debug_line       PROGBITS        0000000000000000 616afd 273a49 00      0   0  1
</span></span><span style=display:flex><span>  [28] .debug_frame      PROGBITS        0000000000000000 88a548 05c2b8 00      0   0  8
</span></span><span style=display:flex><span>  [29] .debug_str        PROGBITS        0000000000000000 8e6800 028332 01  MS  0   0  1
</span></span><span style=display:flex><span>  [30] .debug_ranges     PROGBITS        0000000000000000 90eb32 0089c0 00      0   0  1
</span></span><span style=display:flex><span>  [31] .symtab           SYMTAB          0000000000000000 9174f8 037380 18     32 7723  8
</span></span><span style=display:flex><span>  [32] .strtab           STRTAB          0000000000000000 94e878 0219d8 00      0   0  1
</span></span><span style=display:flex><span>  [33] .shstrtab         STRTAB          0000000000000000 970250 000142 00      0   0  1
</span></span><span style=display:flex><span>Key to Flags:
</span></span><span style=display:flex><span>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
</span></span><span style=display:flex><span>  L (link order), O (extra OS processing required), G (group), T (TLS),
</span></span><span style=display:flex><span>  C (compressed), x (unknown), o (OS specific), E (exclude),
</span></span><span style=display:flex><span>  p (processor specific)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Program Headers:
</span></span><span style=display:flex><span>  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
</span></span><span style=display:flex><span>  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x2f40bc 0x2f40bc R E 0x4000
</span></span><span style=display:flex><span>  LOAD           0x2f7c88 0x00000000002fbc88 0x00000000002fbc88 0x10ce50 0x130a50 RW  0x4000
</span></span><span style=display:flex><span>  DYNAMIC        0x2f7dd0 0x00000000002fbdd0 0x00000000002fbdd0 0x000230 0x000230 RW  0x8
</span></span><span style=display:flex><span>  NOTE           0x000190 0x0000000000000190 0x0000000000000190 0x000024 0x000024 R   0x4
</span></span><span style=display:flex><span>  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
</span></span><span style=display:flex><span>  GNU_RELRO      0x2f7c88 0x00000000002fbc88 0x00000000002fbc88 0x000378 0x000378 R   0x1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> Section to Segment mapping:
</span></span><span style=display:flex><span>  Segment Sections...
</span></span><span style=display:flex><span>   00     .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame
</span></span><span style=display:flex><span>   01     .init_array .fini_array .data.rel.ro .dynamic .data .got.plt .got .sdata .bss
</span></span><span style=display:flex><span>   02     .dynamic
</span></span><span style=display:flex><span>   03     .note.gnu.build-id
</span></span><span style=display:flex><span>   04
</span></span><span style=display:flex><span>   05     .init_array .fini_array .data.rel.ro .dynamic
</span></span></code></pre></div><p>由于 ELF 文件头本身就是平台无关的，使用任何架构的 <code>readelf</code> 都可以读，也不管你是原生工具链，还是交叉工具链。</p><p>出于人类常识，移植一个全新的架构也犯不着把有的没的都全部改一遍，为了改而改，这样反而增加适配的工作量；所以 section 名字也都是熟悉的。那么代码段就还是叫 <code>.text</code>——文本！机器语言对机器而言就是“文本”。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
</span></span><span style=display:flex><span>  [11] .text             PROGBITS        0000000000052a10 052a10 25b058 00  AX  0   0  8
</span></span></code></pre></div><p>这意思就是，这个库的代码段装载到从 <code>0x52a10</code> 开始的一块内存，内容从文件的第 <code>0x52a10</code> 字节（编号从 0 开始）起，长度有 <code>0x25b058</code> 字节。</p><p>马上来看一下！还记得老胡那一页指令格式的 PPT 吗？所有指令都定长 32 位，跟大多数 RISC 架构都一样，那么——</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> struct
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># one little-endian 32-bit word</span>
</span></span><span style=display:flex><span>INSN <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>Struct(<span style=color:#e6db74>&#39;&lt;I&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> fp:
</span></span><span style=display:flex><span>    fp<span style=color:#f92672>.</span>seek(<span style=color:#ae81ff>0x52a10</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    text <span style=color:#f92672>=</span> fp<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>0x25b058</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 先看 10 条指令</span>
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>40</span>:
</span></span><span style=display:flex><span>    insn <span style=color:#f92672>=</span> INSN<span style=color:#f92672>.</span>unpack(text[i:i <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>])[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>insn<span style=color:#e6db74>:</span><span style=color:#e6db74>08x</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>1c0076a4
</span></span><span style=display:flex><span>02dca084
</span></span><span style=display:flex><span>1c0076ac
</span></span><span style=display:flex><span>02dc818c
</span></span><span style=display:flex><span>58001984
</span></span><span style=display:flex><span>1c0076ac
</span></span><span style=display:flex><span>28def18c
</span></span><span style=display:flex><span>40000d80
</span></span><span style=display:flex><span>4c000180
</span></span><span style=display:flex><span>03400000
</span></span></code></pre></div><p>很工整嘛！看上去我们猜的没错——与所有其他常见 RISC 指令集一样，LoongArch 的机器码在内存中，就是一堆原生字节序的整数。对 LoongArch 而言，就是一堆 32 位的小端序整数。像这前两条指令 <code>1c0076a4 02dca084</code>，你如果直接拿十六进制编辑器打开文件，其实在那个位置存放的是 <code>a4 76 00 1c 84 a0 dc 02</code>，每 4 个字节都是反过来的。</p><p>那么我们现在已经找到了整个代码段，借助老胡的 PPT 助攻，我们甚至不用自己统计分析指令格式了，真的爽！何况现在已知的指令格式就有 10 种，还可能有未知的（剧透：真的有！），自己分析还不知要到猴年马月……现在只需要搞明白哪些 opcode 是使用的哪种指令格式，含义是啥就好了。</p><p>接下来，终于可以进入真正指令的破译工作了！欲知后事如何，且听下回分解~</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.xen0n.name/posts/old/reversing-loongarch/part-4/><span class=title>« 上一页</span><br><span>《开局一个二进制，从零开始的 LoongArch 指令集推导》——第四回 把大象放进冰箱</span></a>
<a class=next href=https://blog.xen0n.name/posts/old/reversing-loongarch/part-2/><span class=title>下一页 »</span><br><span>《开局一个二进制，从零开始的 LoongArch 指令集推导》——第二回 ELF</span></a></nav></footer><script src=https://utteranc.es/client.js repo=xen0n/xen0n.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>© WANG Xuerui; 以 cc-by-nc-sa 4.0 授权</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>