<!doctype html><html lang=zh-cmn-hans-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>这个博客是怎样搭建的 | write(2)</title><meta name=keywords content><meta name=description content="写给 2022 年点进这篇文章的人们 本文描述的是本博客的第一版样式/生成器。 由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与"><meta name=author content="WÁNG &#34;xen0n&#34; Xuěruì"><link rel=canonical href=https://blog.xen0n.name/posts/meta/making-of-this-blog/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.xen0n.name/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.xen0n.name/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.xen0n.name/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.xen0n.name/apple-touch-icon.png><link rel=mask-icon href=https://blog.xen0n.name/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cmn-hans-cn href=https://blog.xen0n.name/posts/meta/making-of-this-blog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="这个博客是怎样搭建的"><meta property="og:description" content="写给 2022 年点进这篇文章的人们 本文描述的是本博客的第一版样式/生成器。 由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xen0n.name/posts/meta/making-of-this-blog/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-05-11T21:43:50+08:00"><meta property="article:modified_time" content="2015-05-11T21:43:50+08:00"><meta property="og:site_name" content="write(2)"><meta name=twitter:card content="summary"><meta name=twitter:title content="这个博客是怎样搭建的"><meta name=twitter:description content="写给 2022 年点进这篇文章的人们 本文描述的是本博客的第一版样式/生成器。 由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.xen0n.name/posts/"},{"@type":"ListItem","position":2,"name":"这个博客是怎样搭建的","item":"https://blog.xen0n.name/posts/meta/making-of-this-blog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"这个博客是怎样搭建的","name":"这个博客是怎样搭建的","description":"写给 2022 年点进这篇文章的人们 本文描述的是本博客的第一版样式/生成器。 由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与","keywords":[],"articleBody":"写给 2022 年点进这篇文章的人们 本文描述的是本博客的第一版样式/生成器。\n由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与主题模板，使之满足作者的高标准严要求。 目前本博客的技术栈已经更换成 Hugo；本文中描述的内容都放在本博客储存库的历史分支了。\n缘起 实际上, 早在 2013 年我就产生了开博的打算, 当时 GitHub Pages 已经算是知名度相当高的服务了. 于是我注册了域名, 建立了 Pages 的 repo, 开始研究一些静态站点生成的东西. 然而 GitHub Pages 采用的静态站点生成器是 Ruby 阵营的 Jekyll, 因为懒得配置 Ruby 开发环境的缘故, 就一直没有开工. 毕竟我平时不写 Ruby, 单纯为了写博客配一个环境, 怎么想都是小题大作吧. 然而静态站点一定是要用工具自动生成的; 手工维护 HTML 模板和 CSS 的不优雅程度更甚于专门配置一遍 Jekyll. 因为当时本科学习即将结束, 事情很多, 就一直拖着没时间写这么一个工具, 于是拖到了现在.\n中间 2014 年 10 月份的时候, 掺和了 PyCon China 的网站建设, 听说了有 staticjinja 这样的工具. 因为上半年做毕设接触了 Node.js 前端开发, 便产生了用 Python 搭建前端开发环境和构建系统的想法. 然而在随后的工作中, 发现 Python 的前端开发支持并没有想象中的良好, pyScss 这样的关键项目与 Ruby 或者 Node.js 生态系统中的 等价 项目 并未实现真正意义上的并驾齐驱 (parity). 当时在 CPyUG 社区内进行了讨论, 为了构建网站的静态部分, 要不要引入 Node.js 组件; 讨论的结果是为了简化部署流程, 维持纯 Python 的方案. 幸好踩到的坑都可以规避 (work around), 也给上游提交了补丁, 这一套静态站也是平稳地上了线.\n当时对静态站点生成器的理解, 是一个类似 Grunt 的结构, 本质上由多个互相独立的任务组成. 至于知道以 Gulp 为代表的流式构建系统, 那是后来看到我一位入了前端坑的本科同学写的介绍文章之后的事情了. 那时我已经比较熟悉 Grunt 的思维方式了, 就导致个人对 Gulp 始终没法理解, 但毕竟基于流的处理方式能避免读写临时文件的 I/O, 这一点性能优势倒是很快就体会到了, 于是就决定抽时间好好研究下 Gulp.\n于是时间到了 2015 年的 4 月底, 我想着利用 “五一” 的假期顺便把博客做了吧, 试着起了一个 Gulp 的前端项目骨架, 这次 Gulp 的文档一下就看懂了.\n我想是时候把这个坑填上了.\n思路 一个静态站点, 无非是由 HTML、CSS 组成的一堆文件, 可能还加上一些不涉及动态内容的 JS. 而构成站点实际内容的每个 HTML 页面里, 相当一部分却是公共的页面结构, 因此手工维护显然是不靠谱的. 解决这个问题早就有了现成方案 – 模板系统 (templating). 然而手写 HTML 总之是比较蛋疼的; 尤其是使用过 Jade 这种模板语言之后给人的感受, 就像写过 Sass 之后再也不想手写裸 CSS 的感觉一样. 那么我们的想法就是:\n Jade - HTML Sass - CSS  这两步使用 Node.js 完成, 因为这样我就可以绕过 Python 前端工具比较弱的限制了.\n我们的文章使用熟悉的 Markdown 撰写, Markdown 是编译成 HTML 的, 这部分内容要以某种方式综合到上一步生成的静态模板里. 其实在浏览器端用 JS 渲染 Markdown 的话也是可以的; 不过比较正统的方式还是一次性把所有工作都做完. 考虑到大部分现成的模板语言, 其标记本身都是直接写在 HTML 里的, 那我们为何不把标记写进 Jade 模板里, 这样 Jade 看见的是文本, 而编译的结果不就是另一个模板语言的合法输入了吗?\n Jade - Jinja2 Markdown - HTML 片段 Jinja2 - 完整 HTML 页面  选用 Jinja2 是考虑到以下几点:\n 语法和 Django 模板几乎一样, 写起来很爽, 我熟悉的另一个模板语言 Mako 写起来更像 PHP 的感觉, 代码跟输出是混在一起的, 相比之下就不够优雅 Jekyll 的模板也是类似的语法, 对面阵营的小伙伴们也熟悉, 有群众基础 这货貌似已经比 Mako 快了 (Mako 首页曾经声称自己性能最高, 但现在已经变成了 “非常接近 Jinja2”) Jade 貌似不方便扩展? 而且前一步是用 Node.js 完成的, 之后还是想用 Python  这就是整体的实现思路了.\n实现 Node.js 生成模板 并没有什么有趣的内容, 在此基本略过. 这部分代码位于博客 repo 的 _src/ 目录下, 编译结果输出到 _templates/ 目录 (被 .gitignore 了), 又加了个 BrowserSync 调试的功能, 其他的确实没什么了.\nPython 静态网页生成器 这是主要工作; 代码在 _generator/ 目录里, 实际上是个独立的项目, 只不过暂且没什么闲情逸致推到 PyPI 上而已… 项目名字叫 Pybble (发音若 pebble), 是 py-blog 简化发音而来的.\nPybble 的架构是受 Gulp 启发的, 也是基于流的结构. 处理流程放在 pybble.process 包里 (process 这个名字也许会换掉, 不过先这么用着好了):\n# process/base.py from ..stream import SkipFile   class BaseProcess(object):  '''Base class for process passes.'''   name = None  anticausal = False   def __init__(self, prev):  self.prev = prev   def run(self):  '''Process a stream of StreamedFiles.'''  return list(self.run_iter())   def run_iter(self):  if self.prev is None:  # we're source  for sf in self.stream_source():  yield sf   return   # buffer input if we're anticausal  if self.anticausal:  input_files = self.prev.run()  for sf in self.process_buffered(input_files):  yield sf   return   # stream from the previous process  for sf in self.prev.run_iter():  try:  yield self.process_file(sf)  except SkipFile:  # skip this file  pass   def process_file(self, sf):  # base impl does nothing  return sf   def process_buffered(self, files):  return files   def stream_source(self):  '''Provide the stream source if asked to be the source process.'''   # base impl returns empty iterable  return [] 核心思路就是这样, 由多个 processes 相互连接构成一条流, 其中也允许一些 processes 看到所有文件而非流式处理, 就可以实现一些生成目录、标签这样的需要预先读取所有输入的功能了. 具体的实现都在 pybble.process 包里, 这里就不摘抄了… 比起具体流程的实现, 我们更关心这些流程是如何串起来的, 在 Pybble 里我们是通过配置文件来控制数据流的. 从命令行入口 (pybble.cli) 调用 build 命令时, 我们通过 pybble.conf 包加载 YAML 格式的配置文件, 里面就包含了 0 或多条流的定义; 这些定义将由 pybble.driver 包转化为相应的一串 process 类实例:\n# driver/__init__.py from .. import process  import six   def stream_from_config(config):  '''Instantiate linked processes from a stream config.'''   return six.moves.reduce(_process_from_config, config, None)   def _process_from_config(sofar, process_decl):  '''Instantiate a process with the given config.'''   name, options = process_decl['name'], process_decl.get('args', {})  return process.get_process(name, options, sofar)   # process/__init__.py def get_process(name, params, prev_process=None):  return _KNOWN_PROCESSES[name](prev_process, **params) 这里略去了注册流程类的内容… 如你所见, 就是一个实例化 processes 并相互连接的过程.\n# driver/__init__.py (continued) class StreamDriver(object):  '''Stream driver driving one or more streams.'''   def __init__(self, streams, callback=None):  self.streams = streams  self.callback = callback   @classmethod  def from_config(cls, config, **kwargs):  streams = [stream_from_config(stream_decl) for stream_decl in config]  return cls(streams, **kwargs)   def execute(self):  nb_streams = len(self.streams)  result_queue = queue.Queue(nb_streams)  threads = [  StreamDriverThread(process, str(idx), result_queue)  for idx, process in enumerate(self.streams)  ]   for thread in threads:  thread.start()   for i in range(nb_streams):  result = result_queue.get()  if self.callback is not None:  self.callback(result)   # this shouldn't be necessary but do it anyway  for thread in threads:  thread.join() 多线程执行, 一个线程对应一条流, 于是我们可以实现很多条流同时运行了. 这里暂时无视掉 Python 的 GIL… 所幸 Python 在进行 I/O 操作时会释放 GIL, 对于 I/O-bound 的 Pybble 而言, 只能单线程跑 CPU-bound 的渲染过程对性能的影响应该并不大.\n关于 Pybble 的配置, 文件名我参考了 Travis CI 的 .travis.yml 和 Jekyll 的 _config.yml, 取了一个十分山寨的 _pybble.yml, 在里头跑了两条流, 一条是编译 HTML 页面, 一条是拷贝静态 assets. 至于为什么不直接让 Gulp 输出成品的静态 assets 到 static/ 目录呢? 这是考虑万一有需要再次预处理 assets 中的内容 (比如在 CSS 里注入点生成内容什么的), 就不必改目录结构了.\nWrapping it up 为了少打字, 我又写了一个简单的 Makefile, 这样就可以打 make 构建整个站点啦. 当然, 相比 Jekyll 的服务器端自动运行, Pybble 只能在本地运行, 相应地每次更新完内容都要多做一次 commit, 显得十分不优雅; 但毕竟这一点无法 work around, 就忍了吧. 至于为什么我没有放一个 .nojekyll 完全禁用 Jekyll? 我测试过, 显然禁用了 Jekyll 会造成所有跟内容无关的文件都出现在网站目录下, 包括所有的配置文件和构建系统相关的内容… 出于强迫症, 我觉得留着 Jekyll 让它实现一个选择性拷贝的功能还是不错的, 所以就把 .nojekyll 给 revert 掉了.\n后记 其实这一套系统还可以做到更多, 比如支持个标签啦分类什么的, 本质上跟实现首页文章索引没什么区别; 加个评论模块也很方便, 实际上评论模块对站点生成器而言就是一段静态代码, 直接写进模板就好. 不过目前来看, 先做这么多吧, 还有很多事情要做呢, 知乎上好像还有好多坑没填呢… (逃\n","wordCount":"2756","inLanguage":"zh-cmn-hans-cn","datePublished":"2015-05-11T21:43:50+08:00","dateModified":"2015-05-11T21:43:50+08:00","author":[{"@type":"Person","name":"WÁNG \"xen0n\" Xuěruì"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.xen0n.name/posts/meta/making-of-this-blog/"},"publisher":{"@type":"Organization","name":"write(2)","logo":{"@type":"ImageObject","url":"https://blog.xen0n.name/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.xen0n.name/ accesskey=h title="write(2) (Alt + H)">write(2)</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.xen0n.name/en/ title="English (US)" aria-label=:us:>🇺🇸</a></li></ul></span></div><ul id=menu><li><a href=https://blog.xen0n.name/archives title=所有文章><span>所有文章</span></a></li><li><a href=https://blog.xen0n.name/%E6%96%87%E7%AB%A0%E7%B1%BB%E5%88%AB title=文章类别><span>文章类别</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.xen0n.name/>主页</a>&nbsp;»&nbsp;<a href=https://blog.xen0n.name/posts/>Posts</a></div><h1 class=post-title>这个博客是怎样搭建的</h1><div class=post-meta><span title="2015-05-11 21:43:50 +0800 +0800">2015/05/11</span>&nbsp;·&nbsp;预计阅读时间: 6 分钟&nbsp;·&nbsp;WÁNG "xen0n" Xuěruì</div></header><div class=post-content><h2 id=写给-2022-年点进这篇文章的人们>写给 2022 年点进这篇文章的人们<a hidden class=anchor aria-hidden=true href=#写给-2022-年点进这篇文章的人们>#</a></h2><p>本文描述的是本博客的第一版样式/生成器。</p><p>由于时过境迁，作者已不再有足够时间、精力自行维护先前简陋的静态站点生成器与主题模板，使之满足作者的高标准严要求。
目前本博客的技术栈已经更换成 <a href=https://gohugo.io>Hugo</a>；本文中描述的内容都放在<a href=https://github.com/xen0n/xen0n.github.io/tree/old-site>本博客储存库的历史分支</a>了。</p><h2 id=缘起>缘起<a hidden class=anchor aria-hidden=true href=#缘起>#</a></h2><p>实际上, 早在 2013 年我就产生了开博的打算, 当时 GitHub Pages 已经算是知名度相当高的服务了.
于是我注册了域名, 建立了 Pages 的 repo, 开始研究一些静态站点生成的东西.
然而 GitHub Pages 采用的静态站点生成器是 Ruby 阵营的 Jekyll, 因为懒得配置 Ruby
开发环境的缘故, 就一直没有开工. 毕竟我平时不写 Ruby, 单纯为了写博客配一个环境,
怎么想都是小题大作吧. 然而静态站点一定是要用工具自动生成的; 手工维护 HTML 模板和
CSS 的不优雅程度更甚于专门配置一遍 Jekyll. 因为当时本科学习即将结束, 事情很多,
就一直拖着没时间写这么一个工具, 于是拖到了现在.</p><p>中间 2014 年 10 月份的时候, 掺和了 <a href=http://cn.pycon.org/>PyCon China</a> 的网站建设, 听说了有
<a href=https://github.com/Ceasar/staticjinja>staticjinja</a> 这样的工具. 因为上半年做毕设接触了 Node.js 前端开发, 便产生了用
Python 搭建前端开发环境和构建系统的想法. 然而在随后的工作中, 发现 Python
的前端开发支持并没有想象中的良好, <a href=https://github.com/Kronuz/pyScss>pyScss</a> 这样的关键项目与 Ruby 或者 Node.js
生态系统中的 <a href=https://github.com/sass/sass>等价</a> <a href=https://github.com/sass/node-sass>项目</a> 并未实现真正意义上的并驾齐驱 (parity).
当时在 CPyUG 社区内进行了讨论, 为了构建网站的静态部分, 要不要引入 Node.js 组件;
讨论的结果是为了简化部署流程, 维持纯 Python 的方案. 幸好踩到的坑都可以规避 (work around),
也给上游提交了补丁, 这一套静态站也是平稳地上了线.</p><p>当时对静态站点生成器的理解, 是一个类似 Grunt 的结构, 本质上由多个互相独立的任务组成.
至于知道以 Gulp 为代表的流式构建系统, 那是后来看到我一位入了前端坑的本科同学写的<a href=http://www.cnblogs.com/myqianlan/p/4195999.html>介绍文章</a>之后的事情了.
那时我已经比较熟悉 Grunt 的思维方式了, 就导致个人对 Gulp 始终没法理解,
但毕竟基于流的处理方式能避免读写临时文件的 I/O, 这一点性能优势倒是很快就体会到了,
于是就决定抽时间好好研究下 Gulp.</p><p>于是时间到了 2015 年的 4 月底, 我想着利用 &ldquo;五一&rdquo; 的假期顺便把博客做了吧, 试着起了一个
Gulp 的前端项目骨架, 这次 Gulp 的文档一下就看懂了.</p><p>我想是时候把这个坑填上了.</p><h2 id=思路>思路<a hidden class=anchor aria-hidden=true href=#思路>#</a></h2><p>一个静态站点, 无非是由 HTML、CSS 组成的一堆文件, 可能还加上一些不涉及动态内容的 JS.
而构成站点实际内容的每个 HTML 页面里, 相当一部分却是公共的页面结构, 因此手工维护显然是不靠谱的.
解决这个问题早就有了现成方案 &ndash; 模板系统 (templating). 然而手写 HTML 总之是比较蛋疼的;
尤其是使用过 Jade 这种模板语言之后给人的感受, 就像写过 Sass 之后再也不想手写裸
CSS 的感觉一样. 那么我们的想法就是:</p><ul><li>Jade -> HTML</li><li>Sass -> CSS</li></ul><p>这两步使用 Node.js 完成, 因为这样我就可以绕过 Python 前端工具比较弱的限制了.</p><p>我们的文章使用熟悉的 Markdown 撰写, Markdown 是编译成 HTML 的, 这部分内容要以某种方式综合到上一步生成的静态模板里.
其实在浏览器端用 JS 渲染 Markdown 的话也是可以的; 不过比较正统的方式还是一次性把所有工作都做完.
考虑到大部分现成的模板语言, 其标记本身都是直接写在 HTML 里的, 那我们为何不把标记写进 Jade 模板里,
这样 Jade 看见的是文本, 而编译的结果不就是另一个模板语言的合法输入了吗?</p><ul><li>Jade -> Jinja2</li><li>Markdown -> HTML 片段</li><li>Jinja2 -> 完整 HTML 页面</li></ul><p>选用 Jinja2 是考虑到以下几点:</p><ul><li>语法和 Django 模板几乎一样, 写起来很爽, 我熟悉的另一个模板语言 Mako 写起来更像 PHP 的感觉, 代码跟输出是混在一起的, 相比之下就不够优雅</li><li>Jekyll 的模板也是类似的语法, 对面阵营的小伙伴们也熟悉, 有群众基础</li><li>这货貌似已经比 Mako 快了 (Mako 首页曾经声称自己性能最高, 但现在已经变成了 &ldquo;非常接近 Jinja2&rdquo;)</li><li>Jade 貌似不方便扩展? 而且前一步是用 Node.js 完成的, 之后还是想用 Python</li></ul><p>这就是整体的实现思路了.</p><h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2><h3 id=nodejs-生成模板>Node.js 生成模板<a hidden class=anchor aria-hidden=true href=#nodejs-生成模板>#</a></h3><p>并没有什么有趣的内容, 在此基本略过. 这部分代码位于博客 repo 的 <a href=https://github.com/xen0n/xen0n.github.io/tree/master/_src><code>_src/</code></a> 目录下,
编译结果输出到 <code>_templates/</code> 目录 (被 .gitignore 了), 又加了个 BrowserSync
调试的功能, 其他的确实没什么了.</p><h3 id=python-静态网页生成器>Python 静态网页生成器<a hidden class=anchor aria-hidden=true href=#python-静态网页生成器>#</a></h3><p>这是主要工作; 代码在 <a href=https://github.com/xen0n/xen0n.github.io/tree/master/_generator><code>_generator/</code></a> 目录里, 实际上是个独立的项目, 只不过暂且没什么闲情逸致推到 PyPI 上而已&mldr;
项目名字叫 Pybble (发音若 pebble), 是 <code>py-blog</code> 简化发音而来的.</p><p>Pybble 的架构是受 Gulp 启发的, 也是基于流的结构. 处理流程放在 <code>pybble.process</code> 包里 (<code>process</code> 这个名字也许会换掉, 不过先这么用着好了):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># process/base.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> ..stream <span style=color:#f92672>import</span> SkipFile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseProcess</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Base class for process passes.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    anticausal <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, prev):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Process a stream of StreamedFiles.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> list(self<span style=color:#f92672>.</span>run_iter())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_iter</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>prev <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># we&#39;re source</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> sf <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>stream_source():
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> sf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># buffer input if we&#39;re anticausal</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>anticausal:
</span></span><span style=display:flex><span>            input_files <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>prev<span style=color:#f92672>.</span>run()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> sf <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>process_buffered(input_files):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> sf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># stream from the previous process</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> sf <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>prev<span style=color:#f92672>.</span>run_iter():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> self<span style=color:#f92672>.</span>process_file(sf)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>except</span> SkipFile:
</span></span><span style=display:flex><span>                <span style=color:#75715e># skip this file</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_file</span>(self, sf):
</span></span><span style=display:flex><span>        <span style=color:#75715e># base impl does nothing</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_buffered</span>(self, files):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> files
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>stream_source</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Provide the stream source if asked to be the source process.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># base impl returns empty iterable</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> []
</span></span></code></pre></div><p>核心思路就是这样, 由多个 processes 相互连接构成一条流, 其中也允许一些 processes
看到所有文件而非流式处理, 就可以实现一些生成目录、标签这样的需要预先读取所有输入的功能了.
具体的实现都在 <code>pybble.process</code> 包里, 这里就不摘抄了&mldr; 比起具体流程的实现,
我们更关心这些流程是如何串起来的, 在 Pybble 里我们是通过配置文件来控制数据流的.
从命令行入口 (<code>pybble.cli</code>) 调用 <code>build</code> 命令时, 我们通过 <code>pybble.conf</code> 包加载
YAML 格式的配置文件, 里面就包含了 0 或多条流的定义; 这些定义将由 <code>pybble.driver</code>
包转化为相应的一串 process 类实例:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># driver/__init__.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> .. <span style=color:#f92672>import</span> process
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> six
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>stream_from_config</span>(config):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Instantiate linked processes from a stream config.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> six<span style=color:#f92672>.</span>moves<span style=color:#f92672>.</span>reduce(_process_from_config, config, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_process_from_config</span>(sofar, process_decl):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Instantiate a process with the given config.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    name, options <span style=color:#f92672>=</span> process_decl[<span style=color:#e6db74>&#39;name&#39;</span>], process_decl<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;args&#39;</span>, {})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> process<span style=color:#f92672>.</span>get_process(name, options, sofar)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># process/__init__.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_process</span>(name, params, prev_process<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _KNOWN_PROCESSES[name](prev_process, <span style=color:#f92672>**</span>params)
</span></span></code></pre></div><p>这里略去了注册流程类的内容&mldr; 如你所见, 就是一个实例化 processes 并相互连接的过程.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># driver/__init__.py (continued)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StreamDriver</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Stream driver driving one or more streams.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, streams, callback<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>streams <span style=color:#f92672>=</span> streams
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>callback <span style=color:#f92672>=</span> callback
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_config</span>(cls, config, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        streams <span style=color:#f92672>=</span> [stream_from_config(stream_decl) <span style=color:#66d9ef>for</span> stream_decl <span style=color:#f92672>in</span> config]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cls(streams, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute</span>(self):
</span></span><span style=display:flex><span>        nb_streams <span style=color:#f92672>=</span> len(self<span style=color:#f92672>.</span>streams)
</span></span><span style=display:flex><span>        result_queue <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>Queue(nb_streams)
</span></span><span style=display:flex><span>        threads <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>                StreamDriverThread(process, str(idx), result_queue)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> idx, process <span style=color:#f92672>in</span> enumerate(self<span style=color:#f92672>.</span>streams)
</span></span><span style=display:flex><span>                ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(nb_streams):
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> result_queue<span style=color:#f92672>.</span>get()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>callback <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>callback(result)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># this shouldn&#39;t be necessary but do it anyway</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>join()
</span></span></code></pre></div><p>多线程执行, 一个线程对应一条流, 于是我们可以实现很多条流同时运行了. 这里暂时无视掉
Python 的 GIL&mldr; 所幸 Python 在进行 I/O 操作时会释放 GIL, 对于 I/O-bound 的
Pybble 而言, 只能单线程跑 CPU-bound 的渲染过程对性能的影响应该并不大.</p><p>关于 Pybble 的配置, 文件名我参考了 Travis CI 的 <code>.travis.yml</code> 和 Jekyll 的
<code>_config.yml</code>, 取了一个十分山寨的 <code>_pybble.yml</code>, 在里头跑了两条流, 一条是编译 HTML 页面,
一条是拷贝静态 assets. 至于为什么不直接让 Gulp 输出成品的静态 assets 到 <code>static/</code>
目录呢? 这是考虑万一有需要再次预处理 assets 中的内容 (比如在 CSS 里注入点生成内容什么的),
就不必改目录结构了.</p><h3 id=wrapping-it-up>Wrapping it up<a hidden class=anchor aria-hidden=true href=#wrapping-it-up>#</a></h3><p>为了少打字, 我又写了一个简单的 Makefile, 这样就可以打 <code>make</code> 构建整个站点啦.
当然, 相比 Jekyll 的服务器端自动运行, Pybble 只能在本地运行, 相应地每次更新完内容都要多做一次 commit,
显得十分不优雅; 但毕竟这一点无法 work around, 就忍了吧. 至于为什么我没有放一个
<code>.nojekyll</code> 完全禁用 Jekyll? 我测试过, 显然禁用了 Jekyll 会造成所有跟内容无关的文件都出现在网站目录下,
包括所有的配置文件和构建系统相关的内容&mldr; 出于强迫症, 我觉得留着 Jekyll 让它实现一个选择性拷贝的功能还是不错的, 所以就把 <code>.nojekyll</code> 给 revert 掉了.</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>其实这一套系统还可以做到更多, 比如支持个标签啦分类什么的, 本质上跟实现首页文章索引没什么区别;
加个评论模块也很方便, 实际上评论模块对站点生成器而言就是一段静态代码, 直接写进模板就好.
不过目前来看, 先做这么多吧, 还有很多事情要做呢, 知乎上好像还有好多坑没填呢&mldr; (逃</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.xen0n.name/posts/old/meizu-mx4-cm/faq/><span class=title>« 上一页</span><br><span>CyanogenMod for 魅族 MX4: 常见问题解答 #1</span></a>
<a class=next href=https://blog.xen0n.name/posts/misc/hello-world/><span class=title>下一页 »</span><br><span>hello world</span></a></nav></footer><script src=https://utteranc.es/client.js repo=xen0n/xen0n.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>© WANG Xuerui; 以 cc-by-nc-sa 4.0 授权</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>