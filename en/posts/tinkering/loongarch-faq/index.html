<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20) | write(2)</title>
<meta name=keywords content>
<meta name=description content="Foreword The LoongArch has garnered much attention since its public debut in 2021, disproportionate to its infancy status both in terms of age and market share (and we are being complimentary here). Most of public information surrounding this architecture, however, comes from press releases of the Loongson Technology Corporation Limited (the Loongson Corporation; website is Chinese-only); this is in stark contrast with all the attention it is receiving from (open-source)">
<meta name=author content="WÁNG &#34;xen0n&#34; Xuěruì">
<link rel=canonical href=https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.xen0n.name/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.xen0n.name/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.xen0n.name/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.xen0n.name/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.xen0n.name/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<link rel=alternate hreflang=zh-cmn-hans-cn href=https://blog.xen0n.name/posts/tinkering/loongarch-faq/>
<link rel=alternate hreflang=en href=https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)">
<meta property="og:description" content="Foreword The LoongArch has garnered much attention since its public debut in 2021, disproportionate to its infancy status both in terms of age and market share (and we are being complimentary here). Most of public information surrounding this architecture, however, comes from press releases of the Loongson Technology Corporation Limited (the Loongson Corporation; website is Chinese-only); this is in stark contrast with all the attention it is receiving from (open-source)">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-12T14:55:00+08:00">
<meta property="article:modified_time" content="2022-02-12T14:55:00+08:00"><meta property="og:site_name" content="write(2)">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)">
<meta name=twitter:description content="Foreword The LoongArch has garnered much attention since its public debut in 2021, disproportionate to its infancy status both in terms of age and market share (and we are being complimentary here). Most of public information surrounding this architecture, however, comes from press releases of the Loongson Technology Corporation Limited (the Loongson Corporation; website is Chinese-only); this is in stark contrast with all the attention it is receiving from (open-source)">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.xen0n.name/en/posts/"},{"@type":"ListItem","position":2,"name":"The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)","item":"https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)","name":"The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)","description":"Foreword The LoongArch has garnered much attention since its public debut in 2021, disproportionate to its infancy status both in terms of age and market share (and we are being complimentary here). Most of public information surrounding this architecture, however, comes from press releases of the Loongson Technology Corporation Limited (the Loongson Corporation; website is Chinese-only); this is in stark contrast with all the attention it is receiving from (open-source)","keywords":[],"articleBody":"Foreword The LoongArch has garnered much attention since its public debut in 2021, disproportionate to its infancy status both in terms of age and market share (and we are being complimentary here). Most of public information surrounding this architecture, however, comes from press releases of the Loongson Technology Corporation Limited (the Loongson Corporation; website is Chinese-only); this is in stark contrast with all the attention it is receiving from (open-source) communities worldwide. This may be enough for those people whose job is primarily attending conferences telling stories, making (often empty) promises for bringing investment, but definitely nowhere near satisfactory for ordinary developers who have to get the actual job done.\nThis FAQ document strives to tell the facts around the LoongArch, in hopes of being useful to fellow developers. But commercial things are invariably controversial, so we also make an effort to take a neutral stance and try to equally present the disagreeing opinions.\nThis document is being updated from time to time, and changes are always accompanied with update dates. The version you are currently reading is last updated at 2022-02-20. (Dates are always in the YYYY-MM-DD format, for ease of tracking changes between the original and the translations.)\nDisclaimer: Information presented in this document is all taken from publicly available sources, except those explicitly marked as opinions. Opinions are always explicitly marked as such, and are strictly personal and have nothing to do with the author’s employer, Loongson Corporation or any other entity. The author is not affiliated with any of the companies part of the Loongson or MIPS ecosystem.\nChangelog You can view the change details at this article’s Git history.\n 2022-02-20: Added translation to English; synced wording adjustments and layout tweaks with the Chinese original. 2022-02-15: Adjusted wording. 2022-02-13: Adjusted wording; added information about instruction formats and assembly language. 2022-02-12: Initial version.  About the ISA What’s LoongArch?  The LoongArch architecture (LoongArch) is an Instruction Set Architecture (ISA) that has Reduced Instruction Set Computer (RISC) style.\n– LoongArch Reference Manual, Volume 1: Basic Architecture\n LoongArch is an instruction set architecture designed by the Loongson Corporation, publicly announced in 2020. Shipping started in 2021 with the 3A5000 products.\nThe Chinese name for LoongArch is 龙芯架构 (Simplified Chinese because the Loongson Corporation is based in Beijing; 龍芯架構 in Traditional characters), according to the title and first sentence of the original manual.\nWhat does LoongArch’s logo look like? LoongArch does not have a logo according to public information. Its trademark is just plain text.\nIt is actually strange to not have a logo, though, because a good logo certainly helps a lot in brand promotion. Hope we can see one in 2022!\nWhat’s the etymology of the word LoongArch, and how to pronounce it? (Note: the English pronunciation described here is American.)\nObviously the word is a portmanteau of “龙芯” (Loongson) and “architecture”. Because of this, it should also be pronounced as such, as a mixture of the two words: /lʊŋ˧˥ɕin˥˥/ + /ˈɑɹkɪtɛkt͡ʃɚ/ = /ˈlʊŋ˧˥ˌɑɹk/ (“龙Arc”, “lóng arc”). This would be “lóng à ke” in typical Chinglish accent 😏\nIn practice, the “Arch” part is often just pronounced /ɑɹt͡ʃ/, the same reason why the word “char” often does not get pronounced as “car”. This pronunciation is acceptable as well. This would be “lóng à chi” or “lóng à qu” in typical Chinglish accent 😏\nWhat are the basic features of LoongArch as an ISA? LoongArch is a register-register architecture which:\n supports 32-bit and 64-bit operations, is little-endian-only, has 32-bit fixed-length instruction words.  Some observations   LoongArch opcodes all extend from MSB to LSB, i.e. are allocated in a “prefix encoding” fashion.\nThis is helpful for conserving the encoding space. Of course, it also means that there is no well-defined “opcode” field in LoongArch; although the 6 highest bits are currently guaranteed to be part of the opcode, and can tell something about instructions' “functional classification”, there is little more.\n Author’s comments:\nPrefix encoding is not the optimal choice from a purely technical perspective: suffix encoding achieves the same conservation effect, while also enabling transparent support for compressed instructions on little-endian architectures.\nTake the RVC extension for example: all information necessary for determining the instruction length is guaranteed to be present in the first byte fetched, thus the decoder can always correctly figure out the instruction length without asking to fetch more bytes than strictly necessary.\nThe LoongArch approach precludes the possibility of shorter instruction words in the same machine mode, because the opcode sits at MSB side and has no well-defined segments, making it impossible to see enough of opcode with instruction fetches shorter than 4 bytes. For example, suppose the first instruction after a reset or a jump is 2 bytes long. Fetching 4 bytes is clearly wrong here; but if only 2 bytes are fetched while the instruction is actually 4 bytes long, then the fetch may well only see the LSB-portion that are actually operands. But the operand fields are arbitrarily specified by the programmer, and boom! the core runs amok.\nIf this problem was not overlooked in the design phase, then the most probable reason behind the design decision could be that “code density improvements with 16-bit instruction words are not worthwhile for actual business cases”.\n   LoongArch is a rather classical RISC design.\nComplete with fixed-length instructions, 32 registers, hard-wired zero register, 3-operand instructions, pure computations that do not touch memory, flat memory model, etc…\n  Some of the LoongArch operations are more powerful than (pre-R6) MIPS and RISC-V.\nJumps and PIC-related operations have wide immediate fields; immediates are loaded in 4 instructions at most without shifting; the ABI even reserves one register for future use, while having enough for almost all cases; various bitwise operations lacking in the RISC-V base ISA are present in that of LoongArch.\n  On the widths of operations LoongArch follows the classical approach (as with x86 or MIPS) in defining the widths for operations: for almost all operations, the operand width of a specific opcode does not change with the register width, as determined by the µarch or the current machine mode. For example, the add.d instruction either is illegal in the current machine mode / on a particular core, or always represents the 64-bit addition operation. The add.w instruction always exists (because there is no LoongArch core with at most 16-bit support), and always represents the 32-bit addition operation.\n   Μarch/Machine mode Instruction Legal? Operation represented     LA32 add.w ⭕ 32-bit addition   LA32 add.d ❌ -   LA64 add.w ⭕ 32-bit addition   LA64 add.d ⭕ 64-bit addition    Compare this with the RISC-V approach: still using additions for our example, the add instruction always operates on native (XLEN) width operands, representing the 32-bit addition on RV32 cores, and 64-bit addition on RV64 cores. Meanwhile, the addw instruction brought by RV64 only operates on the lower 32-bit even on RV64 cores, but this instruction does not exist on RV32 cores.\n   Μarch/Machine mode Instruction Legal? Operation represented     RV32 addw ❌ -   RV32 add ⭕ Native-width addition (XLEN=32)   RV64 addw ⭕ 32-bit addition   RV64 add ⭕ Native-width addition (XLEN=64)    (Trivia: this is one of the biggest mistakes your author made, while reverse-engineering LoongArch from scratch before Loongson released the ISA manual – assuming that LoongArch specified its operand widths just like RISC-V. 😂)\nHow many instruction formats do LoongArch have? tl;dr There are 9 typical instruction formats. But in fact there are 39, based on real effort needed in porting low-level software.\nLoongson’s “official” stance According to LoongArch Reference Manual, Volume 1, there are 9 typical instruction formats.\n   No immediate With immediate     2R 2RI8   3R 2RI12   4R 2RI14    2RI16    1RI21    I26    Which look like this when pictured:\n .loongarch-insn-formats { table-layout: fixed !important; font-family: \"Fira Code\", \"Inziu Iosevka\", \"Source Code Pro\", \"Menlo\", \"Consolas\", monospace; } .loongarch-insn-formats th, .loongarch-insn-formats td { min-width: 1rem !important; padding: 0.1rem !important; border: 1px solid var(--border); text-align: center !important; } .loongarch-insn-formats th { background-color: var(--code-bg); } .loongarch-insn-formats th:first-child, .loongarch-insn-formats tbody td:first-child { background-color: var(--code-bg); } .loongarch-insn-formats td { font-size: 14px; /* same as th */ } .loongarch-insn-formats .field-opcode { background-color: var(--code-bg); }    Format Instruction word   3130292827262524 2322212019181716 15141312111098 76543210    2Rrjrd 3Rrkrjrd 4Rrarkrjrd 2RI8immrjrd 2RI12immrjrd 2RI14immrjrd 2RI16immrjrd 1RI21imm lowrjimm high I26imm lowimm high   Note: cells with this background represent opcode bits.    There are a few instructions whose encoding style is not completely equivalent to these 9 typical instruction formats. However, the number of such instructions is small and the instructions change little, which will not be inconvenient for compiler developers.\n “change little” 😏\nThe truth According to the answer above, in fact LoongArch has no well-defined instruction formats or operand slots. Although most instructions have reasonably consistent encodings, the few that do require special encoding are encoded almost arbitrarily.\nIndeed, people still have to define all the instruction format variants when developing (dis-)assemblers, because the machine does not care which format is “more typical” than others; different is different. We can observe this phenomenon in most open-source projects with this kind of low-level handling:\n binutils: MIPS、RISC-V、SPARC; there may or may not be definitions for the different instruction formats, but there are always complete description for operand slots. LLVM: MIPS、RISC-V; significantly more instruction formats defined than the few “basic formats” described on manuals. QEMU: HPPA、RISC-V; ditto.  If we classify the instruction formats according to the strict rule of “different bit-fields or different operand types, different format”, then the v1.00 LoongArch base ISA has a total of 39 distinct instruction formats. The community-maintained loongarch-opcodes project provides a collection of all publicly known LoongArch instructions, and a precise naming scheme for instruction formats. (Disclaimer: your author is the maintainer of this project.)\nHere are the 39 precisely defined LoongArch instruction formats (consult the loongarch-opcodes documentation for meanings of the operand slot names):\n  Format Instruction word   3130292827262524 2322212019181716 15141312111098 76543210    CdFjFjCd CdFjFkFkFjCd CdJJCd CjSd5k16Sd5k16 lowCjSd5k16 high DCjCjD DFjFjD DJJD DJKKJD DJKUa2Ua2KJD DJKUa3Ua3KJD DJSk12Sk12JD DJSk14Sk14JD DJSk16Sk16JD DJUk12Uk12JD DJUk14Uk14JD DJUk5Uk5JD DJUk5Um5Um5Uk5JD DJUk6Uk6JD DJUk6Um6Um6Uk6JD DJUk8Uk8JD DSj20Sj20D DUj5Uj5D EMPTY FdCjCjFd FdFjFjFd FdFjFkFkFjFd FdFjFkCaCaFkFjFd FdFjFkFaFaFkFjFd FdJJFd FdJKKJFd FdJSk12Sk12JFd JKKJ JKUd5KJUd5 JSd5k16Sd5k16 lowJSd5k16 high JUd5JUd5 JUd5Sk12Sk12JUd5 JUk8Uk8J Sd10k16Sd10k16 lowSd10k16 high Ud15Ud15   Note: cells with this background represent opcode bits.   As is shown, LoongArch actually has vastly more complex encodings than MIPS or RISC-V, both of which have about 20 distinct formats at most. Although some of the LoongArch formats are definitely mergeable (for example the FdCj and CdFj formats; they are the same if we do not pursue complete correspondence of operand order in assembler syntax), that ship has sailed; also the current scheme does conserve a lot of encoding space after all.\nIs the LA464 µarch the same thing as GS464V? Why did it get renamed? This answer contains speculations.\nFrankly speaking, the Loongson Corporation does not really put any special consideration in naming its micro-architectures or cores. For example, the 3A4000 processor contains 4 GS464V cores, but the cores of the much earlier 3B1500 are also called GS464V in the documentation.\n Author’s comment: There is the GS464EV name on Wikipedia, and it is coined by the community exactly because of the desire to avoid ambiguity. The µarch of 3A2000/3A3000 is called GS464E; 3A4000, as a “tock”/µarch iteration, finally gained usable vector support by implementing MSA, hence the GS464EV name.\n(The former vector instructions developed in-house are lacking in terms of functionality and documentation, so this is why we call MSA “usable”.)\n As for the LA464/GA464V, there are expressions like “adjusting ISA of present IP cores” (“调整现有 IP 核的指令系统”) that can be seen in earlier public articles or presentations about the development of the 3A5000 or the LoongArch, e.g. the August 2020 keynote by HU Weiwu. Considering that the 3A4000 and 3A5000 belong to the same tock-tick iteration, such wording may imply that the 3A5000 is just the 3A4000 with a replaced decoder. However, it is not okay to re-use the codename, as the instruction set is incompatible after all; the Loongson Corporation ultimately chose to modify all of its documentation and open-source code to mass-replace GS464V with LA464 for the new LoongArch model, on August 2021.\nSo, overall it is more appropriate to consider the LA464 and GS464V as a not-so-similar “pair of twins”, with roughly the same micro-architecture, but different supported ISA.\nWhat’s the relationship between LoongArch and MIPS? (Please note that all RISC architectures bear a significant resemblance to each other, because all of them are made to perform the same thing called “general-purpose computation”.)\nAccording to public sources, LoongArch and MIPS cannot interoperate, and there is no 1:1 correspondence between some of the important architectural features; though such correspondence exists for many of their instruction semantics.\n LoongArch has entirely different instruction encoding than MIPS. LoongArch does not have any form of branch delay slots, while MIPS did not gain optional delay-slot-less branches/jumps until R6. LoongArch does not feature some of the historical warts of MIPS, for example the “wonderful” HI/LO accumulators. LoongArch’s ABI is based on that of RISC-V, departing from the MIPS tradition. Concepts such as dedicated return value registers and registers reserved for kernel use are abolished.  However, there is objective MIPS influence on LoongArch. For example:\n LoongArch uses predicate registers $fccX for floating-point comparison and branches, which are 8 distinct flag bits; this is the same as MIPS, and rarely seen on other modern architectures. LoongArch’s privileged architecture is similar to that of MIPS. For example, the LoongArch TLB has a special even/odd entry distinction; this is cumbersome, hence not seen on any other prominent architecture but MIPS. Some instructions have identical semantics as their MIPS R6 counterparts, while similar semantically-identical instructions are not found in any other prominent architecture. The LoongArch maskeqz/masknez and the MIPS R6 selnez/seleqz are such an example. The way some operations are implemented are similar to MIPS R6, only with minor changes. For example, 64-bit immediates are materialized in 4 segments, and the 4 instructions used are lu12i.w/ori/lu32i.d/lu52i.d for LoongArch (here using official mnemonics). They only differ from their MIPS R6 counterparts (lui/ori/dahi/dati) in the length of each segment: for LoongArch it is 12/20/20/12, while for MIPS it is 16/16/16/16. Also, this particular way of materializing immediates is not seen on any other prominent architecture. The Loongson Virtualization Extension is abbreviated as LVZ which is extremely dubious. Because “Loongson SIMD Extension” is LSX, “Loongson Advanced SIMD Extension” is LASX and “Loongson Binary Translation Extension” is LBT (asymmetry here; it should have been called LBTX), the virtualization extension should be abbreviated LVX or LV; in no way it is conformant to pick two letters from the second word to get LVZ. VZ is MIPS’s name for its virtualization ASE! The LoongArch assembler syntax is similar to that of MIPS. Parentheses around memory operands are removed, but registers still have to carry a $ prefix, and pseudo-instructions such as move are named after the MIPS counterparts, different from RISC-V etc. Early LoongArch ports of fundamental software such as the toolchain or the Linux kernel are basically just copy-pastes of MIPS code, mass-replacing “MIPS” with “LOONGARCH” along the way. (Of course, because the quality of such code is bound to be low, and the two architectures are not that similar after all, the Loongson Corporation stopped doing this not before long.)  What’s the relationship between LoongArch and RISC-V? (Please note that all RISC architectures bear a significant resemblance to each other, because all of them are made to perform the same thing called “general-purpose computation”.)\nAccording to public sources, LoongArch and RISC-V cannot interoperate, and there is no 1:1 correspondence between some of the important architectural features; though such correspondence exists for many of their instruction semantics if certain conditions are met (restricted to 64-bit operation, for example).\n LoongArch’s privileged architecture and memory management are significantly different to those of RISC-V. The supported operations of LoongArch base ISA are mostly a superset of its RISC-V counterpart. RISC-V always sign-extends its immediate operands, while LoongArch differentiates based on type of operation (sign-extending for arithmetic operations; zero-extending for logical operations). LoongArch has opcodes starting from MSB, precluding compressed instruction words in the RVC way.  There is significant RISC-V influence in the software part of LoongArch, such as the ABI and several fundamental toolchain pieces. LoongArch’s ABI is rather similar to RISC-V’s, and the semantic similarities of instructions are notable as well. Often, simple syntactic tweaks to the RISC-V version are all it takes to port a primitive to LoongArch for some fundamental software.\nSome LoongArch instructions have identical semantics as their RISC-V counterparts; some of the architectural features are similar as well. For example:\n The PIC-related pcaddu12i behaves the same as the RISC-V auipc. The register jump jirl behaves the same as the RISC-V jalr, very unlike the MIPS jalr. The timekeeping instructions rdtime.* are semantically similar to their RISC-V counterparts in that they all return values from a constant-frequency counter. LoongArch’s privileged resources live in the CSR space, and the CSR concept obviously comes from RISC-V. This is already the case back to 3A5000’s predecessor, 3A4000. RISC-V originally defined 4 privilege levels (from high to low, Machine/Hypervisor/Supervisor/User; Hypervisor was later removed), and LoongArch defines 4 too (from high to low, PLV0/PLV1/PLV2/PLV3). However, LoongArch OSes run at the highest level of PLV0, while it is recommended for RISC-V OSes to run at the Supervisor level.  And these are possible influences of RISC-V to LoongArch as well.\nHow many ABIs do LoongArch have? LoongArch currently defines 3x2=6 ABIs, according to the LoongArch ELF psABI.\nData models of which are:\n ILP32 (int, long and pointers are 32-bit wide; a 32-bit model but not completely excluding 64-bit operations) LP64 (long and wider types and pointers are 64-bit wide; this is the most common 64-bit data model in Linux space)  And the floating-point support are:\n Soft-float (S) Single-precision hard-float (F) Double-precision hard-float (D)  Currently only the LP64D ABI is fully supported. All publicly available commercial distributions for LoongArch are built with this ABI. If you attempt to use the other ABIs, you are very likely to get all kinds of compilation errors, so usage of these ABIs is not recommended at this early stage of bring-up. In particular, the support for the ILP32 ABIs are known to be very incomplete, and it is extremely likely that builds will just error out immediately if one ever try.\nWhat happened to LoongArch’s vector extension? This answer is speculative because the relevant documentation has not been released.\nThe 3A4000 from the end of Loongson’s MIPS era contains a complete implementation of MIPS’s MSA vector extension. In addition to that, the 3A4000 also has support for the LoongMMI which is inherited from the 2F era, and the LSX/LASX that never appeared in public documentation. Let’s summarize all these vector extensions:\n MSA: 128-bit fixed vector width, according to the MSA64 documentation v1.12. LoongMMI: usage extremely similar to the x86 MMX; 64-bit fixed vector width. LSX/LASX: public information nearly non-existent aside from a few PPT slides, open-source toolchain code only briefly and quietly appearing before being redacted. LSX should have a fixed vector length of 128-bit, while LASX should have 256.  As can be seen, all the implemented vector instructions operate on fixed vector lengths. Taking the description of the LSX and LASX bits in the LoongArch Reference Manual, Volume 1, Section 2.2.10.5 Table 3 “The configuration information accessible by the CPUCFG instruction” into consideration (“128-bit vector extension” and “256-bit vector extension” respectively), it is presumed that LoongArch’s LSX/LASX are similar to the LSX/LASX from the MIPS era; at least the vector width should be fixed as well. The instruction encodings must have been changed, and some instructions may get added or removed as well; there is no public documentation and open-source support after all, so no external code makes use of these, and compatibility is not a concern in this case.\nNote that novel vector extensions in the recent years are all scalable, such as the AArch64 SVE and the RISC-V RVV: software is able to dynamically configure the vector unit to pick the vector width most suitable to the requirement at hand, also meaning software does not need to be modified to take advantage of wider hardware implementations. This is generally a welcomed trend, and we noticed a change preparing for scalable vectors in Loongson’s glibc fork. Considering there may be multiple reasons for not releasing the LSX/LASX to the public (especially IP concerns), this might mean that LSX/LASX would never become public, and that a scalable vector implementation similar to RVV would be available at some future time.\nWhat happened to LoongArch’s binary translation extension? This answer is speculative because the relevant documentation has not been released.\nSimilar to the case of vector extension, we can speculate based on the binary translation extension from the MIPS era. Although there is no public instruction encodings nor kernel support, we actually already had a sneak peek at the extension, by means of some academic report or public presentations done by Loongson themselves (the August 2020 keynote by HU Weiwu, the April 2021 presentation by ZHANG Fuxin):\n New architectural state of the EFLAGS register is added, along with purely EFLAGS-updating counterparts for some basic instructions; New architectural state of the TOP register is added, along with the corresponding FPU mode bit; semantics of FP register operands is altered to be TOP-based if the x87 emulation mode is enabled.  Loongson later added support for other operations too, such as the ARM conditional execution, and the approach should be similar. So, the x86 and ARM translation aid of LoongArch is likely to be minor tweaks to the previous binary translation extension. As for the translation of MIPS, because both MIPS and LoongArch are classical RISC designs, branch delay slots may be the only hardware aid. (Other weird MIPS features such as HI/LO registers are easily implemented in software at translation time, because you have to recover the data flow regardless.)\nAbout software development I’m going to port my software to LoongArch. What do I need to prepare for? You don’t have to specially prepare for anything!\nThe expectation is for LoongArch to become a “normal” platform for software and hardware development. You just do on LoongArch whatever you used to do for other platforms, such as x86 or ARM, except for those things inherently platform-specific.\nIf you develop for some specific domain with high-level programming languages, you almost never need to care about low-level technical details of the platform. These kind of things are already taken care of by the open-source community, consisting of all enterprise and individual developers using Loongson.\nIf you are an infrastruture developer yourself, or a higher-level developer that occasionally needs to care about low-level details here and there, the LoongArch documentation provided by the Loongson Corporation is a good starting point.\nHow do I quickly familiarize myself with LoongArch assembly? The manual and ABI spec are your friends 😉\nSyntactically, LoongArch’s assembly language is basically a simplified version of MIPS assembly, but there are a few important differences as well. Based on personal experiences, it is easy to quickly on-board oneself by “thinking in RISC-V while writing MIPS”; this, coupled with manual reading, it is easy to master the language as well.\n Registers must be prefixed with $, like MIPS. (In RISC-V assembly this is not necessary.) The ABI divides registers into three classes $a* $t* $s*, like RISC-V. (Different from MIPS; there is no distinct $v* nor $k*.) The way of doing PIC is the same as RISC-V, different from MIPS. (The abicall convention is a compromise to the limited functionality of the pre-R6 MIPS ISA, and as such, there is no point carrying it over to the new era.) The way of doing TLS (Thread-local storage) is the same as RISC-V. (Different from MIPS; LoongArch has the dedicated $tp register so it is no longer necessary to workaround this with things like rdhwr.) The register move pseudo-instruction is called move, like MIPS. (Different from x86 or RISC-V; mov or mv are not recognized.) The no-op is spelled nop as with most architectures. (Syntactic sugar for andi $zero, $zero, 0.) Return from subroutine is jr $ra, like MIPS. (Syntactic sugar for jirl $zero, $ra, 0; different from RISC-V, there is no ret as an additional syntactic sugar as of 2022-02-13.) Different from MIPS, there are no parentheses around registers that represent memory operands. (ld $a0, 16($a1) becomes ld.d $a0, $a1, 16.) A width suffix is needed for the li pseudo-instruction as well. (li.w suffices most of the time; it is seldom necessary to load 64-bit constants.) As for operand ordering of instructions, most follow the rule of registers before immediates, and from LSB to MSB in each group. Note that there are exceptions if using manual syntax!  Aside from these, there are some known inconsistent, misleading or even errorneous descriptions existing in the current version (v1.00) of the ISA manual, due to Loongson not soliciting reviews from the wider community before publishing the manuals. These are all described in the loongarch-opcodes project’s documentation.\n Author’s comments:\nThe loongarch-opcodes review feedbacks are already sent back to relevant teams at Loongson. But they replied with something like “It’s impossible to modify the manuals like that now, after publication, in part also because there’s no precedent of any other company doing this such as Intel or ARM; developers just have to take some more time to get accustomed” 😏 As if developers inside Loongson actually had similar expertise as their fellow Intel or ARM developers, and that everything is done correct in one go. Or do they?\nRegardless, your author and other friends in support of the project are still actively communicating and pushing every fix and improvement forward, in hopes of eliminating as many warts as possible before LoongArch is known to a wider audience. We do not want future developers to fall for the same traps that we had already fallen into.\n I’m using C/C++. How do I specify the CFLAGS on LoongArch? How to conditionally compile for LoongArch and its features? Please consult the LoongArch toolchain convention.\nI don’t have LoongArch hardware. How do I test my software on it nevertheless? You could use QEMU for this most of the time. Both system emulation (emulating a complete LoongArch computer) and user-mode emulation (emulating a LoongArch Linux syscall interface on top of the host Linux kernel) are supported. Usage of QEMU is outside the scope of this documentation; consult other online resources for that.\nNote: As of 2022-02-12, target support for LoongArch is not upstreamed yet. This means you would have to compile Loongson’s development branch yourself.\nAbout the LoongArch ecosystem Which Linux distributions have been ported to LoongArch? Thanks to prioritized hardware access and team collaboration provided by the Loongson Corporation, the commercial development around LoongArch is progressing very rapidly.\nAs of 2022-02-12, multiple commercial distributions (developed by China mainland entities) already provide LoongArch ports. These include but are not limited to: (in alphabetical order)\n Kylin (from the Kylin Software Corporation; website is Chinese-only) Loongnix (from the Loongson Corporation; website is Chinese-only) UOS (from the UnionTech Corporation; website is Chinese-only)  Loongnix claims to be the “Linux OS from the Loongson open-source community”, but because there are actually very few external participants if at all, and some of its packages are not open-source (especially the toolchain; the current Loongnix LoongArch port even has vector extension support!), this distribution is in effect a commercial one.\nAfter the publication of the various LoongArch documentation, and open-sourcing of Loongson forks of fundamental pieces of software, the porting pace of community distributions has accelerated as well.\nThere are several ongoing porting efforts as of 2022-02-12, including but not limited to: (in alphabetical order)\n Arch Linux CLFS Gentoo  Why can’t I run closed-source software like WPS Office on community distributions? (aka What’s this so-called “old world” and “new world”?) As of 2022-02-12, all commercial LoongArch distributions are incompatible with all community distributions. All binary software built on community distributions, and some software written in high-level languages and existing in forms like source code or bytecode (such as those written in Python or Java) cannot run on commercial distributions, and vice versa. All closed-source software from ISVs such as WPS Office are built on commercial distributions, so they are extremely unlikely to work as-is on community distributions.\nThis is the so-called compatibility problem between the old-world and the new-world. Because the Loongson Corporation finished all commercial moves before announcing the LoongArch to the open-source community, the open-source LoongArch ecosystem is the new world; in contrast to this, all commercial distributions and the ecosystem associated make up the old world. The two worlds are to be united eventually, but are two parallel universes for now; and the technical difficulty of making the two worlds compatible with each other is enormous.\nAs for the reason for two worlds and ways to be compatible, that is a long story ;-) Let’s save this for another article, dedicated to the topic and to be written shortly.\nWhat LoongArch hardware can I buy? Although international ways of purchasing Loongson products has largely died out after the 2F era (when international marketing of Loongson products were taken care of by STMicroelectronics), at least in China mainland, you can easily get your hands on various products with LoongArch CPUs, all of which are publicly available. For example, there are ATX boards, prebuilt computers and notebooks with the 3A5000; and there are rack-mounted servers for the 3C5000L.\nThis document cannot provide any link to actual products or shops, due to your author having no affiliation with them, but you can always search for “龙芯” yourself on popular Chinese shopping sites like ○宝, ○东 or ○鱼 (you will know the exact names if you have literally any clue about the Chinese language and the Chinese Internet life in general, or just give this document to one of your helpful Chinese friends 😆).\nNote: the Loongson products are almost always significantly more expensive than similarly specced “mainstream” x86 or ARM products, due to the small production volume. On top of that, there are more fundamental problems for the Loongson platform to solve at this early stage of development, so it is not recommended for casual users to buy.\nHow can I get acquainted with other fellow LoongArch fans? Communities exist for any technology with users, and LoongArch is no exception (your author and his friends are not cats, after all).\nThere are a lot of places on the Internet where Loongson and LoongArch topics are discussed. Some places frequented by many people are (but not limited to):\n Forum of the Loongson Open-source Community (龙芯开源社区论坛) (HTTP-only due to technical reasons; Chinese-only) Loongson Bar on Baidu Tieba (百度贴吧龙芯吧) (Chinese-only) Telegram Loongson group（Chinese \u0026 English） QQ group 922566903 (Chinese-only)  There may be other QQ groups discussing Loongson topics, but your author does not use QQ so he does not know the number. (PM and PRs are welcomed for suggesting more of them!)\nNote that these public venues are better suited to general chatter, instead of serious technical discussion. Because some of the end-user fans take rather radical technical/political positions, technical discussions may easily get derailed if any of the more sensitive topics is inadvertently touched. However, you should be able to find the appropriate place for communication between developers if you possess the desired communication attitude and ability; due to this, links to such places are left out for now. ;-)\n","wordCount":"5495","inLanguage":"en","datePublished":"2022-02-12T14:55:00+08:00","dateModified":"2022-02-12T14:55:00+08:00","author":[{"@type":"Person","name":"WÁNG \"xen0n\" Xuěruì"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/"},"publisher":{"@type":"Organization","name":"write(2)","logo":{"@type":"ImageObject","url":"https://blog.xen0n.name/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.xen0n.name/en/ accesskey=h title="write(2) (Alt + H)">write(2)</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://blog.xen0n.name/ title=简体中文（大陆普通话） aria-label=:cn:>🇨🇳</a>
</li>
</ul>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.xen0n.name/en/archives title=Archive>
<span>Archive</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://blog.xen0n.name/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.xen0n.name/en/posts/>Posts</a></div>
<h1 class=post-title>
The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-02-20)
</h1>
<div class=post-meta><span title="2022-02-12 14:55:00 +0800 +0800">February 12, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;WÁNG "xen0n" Xuěruì&nbsp;|&nbsp;
<ul class=i18n_list>Translations:
<li>
<a href=https://blog.xen0n.name/posts/tinkering/loongarch-faq/>🇨🇳</a>
</li>
</ul>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#foreword aria-label=Foreword>Foreword</a></li>
<li>
<a href=#changelog aria-label=Changelog>Changelog</a></li>
<li>
<a href=#about-the-isa aria-label="About the ISA">About the ISA</a><ul>
<li>
<a href=#whats-loongarch aria-label="What&amp;rsquo;s LoongArch?">What&rsquo;s LoongArch?</a></li>
<li>
<a href=#what-does-loongarchs-logo-look-like aria-label="What does LoongArch&amp;rsquo;s logo look like?">What does LoongArch&rsquo;s logo look like?</a></li>
<li>
<a href=#whats-the-etymology-of-the-word-loongarch-and-how-to-pronounce-it aria-label="What&amp;rsquo;s the etymology of the word LoongArch, and how to pronounce it?">What&rsquo;s the etymology of the word LoongArch, and how to pronounce it?</a></li>
<li>
<a href=#what-are-the-basic-features-of-loongarch-as-an-isa aria-label="What are the basic features of LoongArch as an ISA?">What are the basic features of LoongArch as an ISA?</a><ul>
<li>
<a href=#some-observations aria-label="Some observations">Some observations</a></li>
<li>
<a href=#on-the-widths-of-operations aria-label="On the widths of operations">On the widths of operations</a></li></ul>
</li>
<li>
<a href=#how-many-instruction-formats-do-loongarch-have aria-label="How many instruction formats do LoongArch have?">How many instruction formats do LoongArch have?</a><ul>
<li>
<a href=#tldr aria-label=tl;dr>tl;dr</a></li>
<li>
<a href=#loongsons-official-stance aria-label="Loongson&amp;rsquo;s &amp;ldquo;official&amp;rdquo; stance">Loongson&rsquo;s &ldquo;official&rdquo; stance</a></li>
<li>
<a href=#the-truth aria-label="The truth">The truth</a></li></ul>
</li>
<li>
<a href=#is-the-la464-%c2%b5arch-the-same-thing-as-gs464v-why-did-it-get-renamed aria-label="Is the LA464 µarch the same thing as GS464V? Why did it get renamed?">Is the LA464 µarch the same thing as GS464V? Why did it get renamed?</a></li>
<li>
<a href=#whats-the-relationship-between-loongarch-and-mips aria-label="What&amp;rsquo;s the relationship between LoongArch and MIPS?">What&rsquo;s the relationship between LoongArch and MIPS?</a></li>
<li>
<a href=#whats-the-relationship-between-loongarch-and-risc-v aria-label="What&amp;rsquo;s the relationship between LoongArch and RISC-V?">What&rsquo;s the relationship between LoongArch and RISC-V?</a></li>
<li>
<a href=#how-many-abis-do-loongarch-have aria-label="How many ABIs do LoongArch have?">How many ABIs do LoongArch have?</a></li>
<li>
<a href=#what-happened-to-loongarchs-vector-extension aria-label="What happened to LoongArch&amp;rsquo;s vector extension?">What happened to LoongArch&rsquo;s vector extension?</a></li>
<li>
<a href=#what-happened-to-loongarchs-binary-translation-extension aria-label="What happened to LoongArch&amp;rsquo;s binary translation extension?">What happened to LoongArch&rsquo;s binary translation extension?</a></li></ul>
</li>
<li>
<a href=#about-software-development aria-label="About software development">About software development</a><ul>
<li>
<a href=#im-going-to-port-my-software-to-loongarch-what-do-i-need-to-prepare-for aria-label="I&amp;rsquo;m going to port my software to LoongArch. What do I need to prepare for?">I&rsquo;m going to port my software to LoongArch. What do I need to prepare for?</a></li>
<li>
<a href=#how-do-i-quickly-familiarize-myself-with-loongarch-assembly aria-label="How do I quickly familiarize myself with LoongArch assembly?">How do I quickly familiarize myself with LoongArch assembly?</a></li>
<li>
<a href=#im-using-cc-how-do-i-specify-the-cflags-on-loongarch-how-to-conditionally-compile-for-loongarch-and-its-features aria-label="I&amp;rsquo;m using C/C++. How do I specify the CFLAGS on LoongArch? How to conditionally compile for LoongArch and its features?">I&rsquo;m using C/C++. How do I specify the CFLAGS on LoongArch? How to conditionally compile for LoongArch and its features?</a></li>
<li>
<a href=#i-dont-have-loongarch-hardware-how-do-i-test-my-software-on-it-nevertheless aria-label="I don&amp;rsquo;t have LoongArch hardware. How do I test my software on it nevertheless?">I don&rsquo;t have LoongArch hardware. How do I test my software on it nevertheless?</a></li></ul>
</li>
<li>
<a href=#about-the-loongarch-ecosystem aria-label="About the LoongArch ecosystem">About the LoongArch ecosystem</a><ul>
<li>
<a href=#which-linux-distributions-have-been-ported-to-loongarch aria-label="Which Linux distributions have been ported to LoongArch?">Which Linux distributions have been ported to LoongArch?</a></li>
<li>
<a href=#why-cant-i-run-closed-source-software-like-wps-office-on-community-distributions-aka-whats-this-so-called-old-world-and-new-world aria-label="Why can&amp;rsquo;t I run closed-source software like WPS Office on community distributions? (aka What&amp;rsquo;s this so-called &amp;ldquo;old world&amp;rdquo; and &amp;ldquo;new world&amp;rdquo;?)">Why can&rsquo;t I run closed-source software like WPS Office on community distributions? (aka What&rsquo;s this so-called &ldquo;old world&rdquo; and &ldquo;new world&rdquo;?)</a></li>
<li>
<a href=#what-loongarch-hardware-can-i-buy aria-label="What LoongArch hardware can I buy?">What LoongArch hardware can I buy?</a></li>
<li>
<a href=#how-can-i-get-acquainted-with-other-fellow-loongarch-fans aria-label="How can I get acquainted with other fellow LoongArch fans?">How can I get acquainted with other fellow LoongArch fans?</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=foreword>Foreword<a hidden class=anchor aria-hidden=true href=#foreword>#</a></h2>
<p>The LoongArch has garnered much attention since its public debut in 2021,
disproportionate to its infancy status both in terms of age and market share
(and we are being complimentary here).
Most of public information surrounding this architecture, however, comes from
press releases of <a href=https://www.loongson.cn/>the Loongson Technology Corporation Limited</a>
(the Loongson Corporation; website is Chinese-only); this is in stark contrast
with all the attention it is receiving from (open-source) communities
worldwide.
This may be enough for those people whose job is primarily attending
conferences telling stories, making (often empty) promises for bringing
investment, but definitely nowhere near satisfactory for ordinary developers
who have to get the actual job done.</p>
<p>This FAQ document strives to tell the facts around the LoongArch, in hopes of
being useful to fellow developers.
But commercial things are invariably controversial, so we also make an effort
to take a neutral stance and try to equally present the disagreeing opinions.</p>
<p>This document is being updated from time to time, and changes are always
accompanied with update dates.
The version you are currently reading is last updated at 2022-02-20.
(Dates are always in the YYYY-MM-DD format, for ease of tracking changes
between the original and the translations.)</p>
<p>Disclaimer:
Information presented in this document is all taken from publicly available
sources, except those explicitly marked as opinions.
Opinions are always explicitly marked as such, and are strictly personal and
have nothing to do with the author&rsquo;s employer, Loongson Corporation or any
other entity.
The author is not affiliated with any of the companies part of the Loongson or
MIPS ecosystem.</p>
<h2 id=changelog>Changelog<a hidden class=anchor aria-hidden=true href=#changelog>#</a></h2>
<p>You can view the change details at <a href=https://github.com/xen0n/xen0n.github.io/commits/main/content/posts/tinkering/loongarch-faq.en.md>this article&rsquo;s Git history</a>.</p>
<ul>
<li>2022-02-20: Added translation to English; synced wording adjustments and layout tweaks with the Chinese original.</li>
<li>2022-02-15: Adjusted wording.</li>
<li>2022-02-13: Adjusted wording; added information about instruction formats and assembly language.</li>
<li>2022-02-12: Initial version.</li>
</ul>
<h2 id=about-the-isa>About the ISA<a hidden class=anchor aria-hidden=true href=#about-the-isa>#</a></h2>
<h3 id=whats-loongarch>What&rsquo;s LoongArch?<a hidden class=anchor aria-hidden=true href=#whats-loongarch>#</a></h3>
<blockquote>
<p>The <strong>LoongArch</strong> architecture (LoongArch) is an <strong>I</strong>nstruction <strong>S</strong>et <strong>A</strong>rchitecture (ISA) that has <strong>R</strong>educed <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer (RISC) style.</p>
<p>&ndash; <em>LoongArch Reference Manual, Volume 1: Basic Architecture</em></p>
</blockquote>
<p>LoongArch is an instruction set architecture designed by the Loongson
Corporation, publicly announced in 2020.
Shipping started in 2021 with the 3A5000 products.</p>
<p>The Chinese name for LoongArch is 龙芯架构 (Simplified Chinese because the
Loongson Corporation is based in Beijing; 龍芯架構 in Traditional characters),
according to the title and first sentence of the original manual.</p>
<h3 id=what-does-loongarchs-logo-look-like>What does LoongArch&rsquo;s logo look like?<a hidden class=anchor aria-hidden=true href=#what-does-loongarchs-logo-look-like>#</a></h3>
<p>LoongArch does not have a logo according to public information.
Its trademark is just plain text.</p>
<p>It is actually strange to not have a logo, though, because a good logo
certainly helps a lot in brand promotion. Hope we can see one in 2022!</p>
<h3 id=whats-the-etymology-of-the-word-loongarch-and-how-to-pronounce-it>What&rsquo;s the etymology of the word LoongArch, and how to pronounce it?<a hidden class=anchor aria-hidden=true href=#whats-the-etymology-of-the-word-loongarch-and-how-to-pronounce-it>#</a></h3>
<p>(Note: the English pronunciation described here is American.)</p>
<p>Obviously the word is a portmanteau of &ldquo;<strong>龙</strong>芯&rdquo; (<em>Loong</em>son) and &ldquo;<em>arch</em>itecture&rdquo;.
Because of this, it should also be pronounced as such, as a mixture of the two
words: /<strong>lʊŋ˧˥</strong>ɕin˥˥/ + /ˈ<strong>ɑɹk</strong>ɪtɛkt͡ʃɚ/ = /ˈlʊŋ˧˥ˌɑɹk/ (&ldquo;龙Arc&rdquo;, &ldquo;lóng arc&rdquo;).
<sub>This would be &ldquo;lóng à ke&rdquo; in typical Chinglish accent 😏</sub></p>
<p>In practice, the &ldquo;Arch&rdquo; part is often just pronounced /ɑɹt͡ʃ/, the same
reason why the word &ldquo;char&rdquo; often does not get pronounced as &ldquo;car&rdquo;.
This pronunciation is acceptable as well.
<sub>This would be &ldquo;lóng à chi&rdquo; or &ldquo;lóng à qu&rdquo; in typical Chinglish accent 😏</sub></p>
<h3 id=what-are-the-basic-features-of-loongarch-as-an-isa>What are the basic features of LoongArch as an ISA?<a hidden class=anchor aria-hidden=true href=#what-are-the-basic-features-of-loongarch-as-an-isa>#</a></h3>
<p>LoongArch is a register-register architecture which:</p>
<ul>
<li>supports 32-bit and 64-bit operations,</li>
<li>is little-endian-only,</li>
<li>has 32-bit fixed-length instruction words.</li>
</ul>
<h4 id=some-observations>Some observations<a hidden class=anchor aria-hidden=true href=#some-observations>#</a></h4>
<ul>
<li>
<p><strong>LoongArch opcodes all extend from MSB to LSB, i.e. are allocated in a &ldquo;prefix encoding&rdquo; fashion.</strong></p>
<p>This is helpful for conserving the encoding space.
Of course, it also means that there is no well-defined &ldquo;opcode&rdquo; field in
LoongArch; although the 6 highest bits are currently guaranteed to be part
of the opcode, and can tell something about instructions' &ldquo;functional
classification&rdquo;, there is little more.</p>
<blockquote>
<p>Author&rsquo;s comments:</p>
<p>Prefix encoding is not the optimal choice from a purely technical
perspective: suffix encoding achieves the same conservation effect, while
also enabling transparent support for compressed instructions on
little-endian architectures.</p>
<p>Take the RVC extension for example: all information necessary for
determining the instruction length is guaranteed to be present in the
first byte fetched, thus the decoder can always correctly figure out
the instruction length without asking to fetch more bytes than strictly
necessary.</p>
<p>The LoongArch approach precludes the possibility of shorter instruction
words in the same machine mode, because the opcode sits at MSB side and
has no well-defined segments, making it impossible to see enough of opcode
with instruction fetches shorter than 4 bytes.
For example, suppose the first instruction after a reset or a jump is
2 bytes long. Fetching 4 bytes is clearly wrong here; but if only 2 bytes
are fetched while the instruction is actually 4 bytes long, then the
fetch may well only see the LSB-portion that are actually operands. But
the operand fields are arbitrarily specified by the programmer,
and boom! the core runs amok.</p>
<p>If this problem was not overlooked in the design phase, then the most
probable reason behind the design decision could be that
&ldquo;code density improvements with 16-bit instruction words are not
worthwhile for actual business cases&rdquo;.</p>
</blockquote>
</li>
<li>
<p><strong>LoongArch is a rather classical RISC design.</strong></p>
<p>Complete with fixed-length instructions, 32 registers, hard-wired zero register, 3-operand instructions, pure computations that do not touch memory, flat memory model, etc&mldr;</p>
</li>
<li>
<p><strong>Some of the LoongArch operations are more powerful than (pre-R6) MIPS and RISC-V.</strong></p>
<p>Jumps and PIC-related operations have wide immediate fields;
immediates are loaded in 4 instructions at most without shifting;
the ABI even reserves one register for future use, while having enough for almost all cases;
various bitwise operations lacking in the RISC-V base ISA are present in
that of LoongArch.</p>
</li>
</ul>
<h4 id=on-the-widths-of-operations>On the widths of operations<a hidden class=anchor aria-hidden=true href=#on-the-widths-of-operations>#</a></h4>
<p>LoongArch follows the classical approach (as with x86 or MIPS) in defining the
widths for operations: for almost all operations, the operand width of a
specific opcode does not change with the register width, as determined by the
µarch or the current machine mode.
For example, the <code>add.d</code> instruction either is illegal in the current machine
mode / on a particular core, or always represents the 64-bit addition
operation.
The <code>add.w</code> instruction always exists (because there is no LoongArch core with
at most 16-bit support), and always represents the 32-bit addition operation.</p>
<table>
<thead>
<tr>
<th style=text-align:center>Μarch/Machine mode</th>
<th style=text-align:center>Instruction</th>
<th style=text-align:center>Legal?</th>
<th>Operation represented</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>LA32</td>
<td style=text-align:center><code>add.w</code></td>
<td style=text-align:center>⭕</td>
<td>32-bit addition</td>
</tr>
<tr>
<td style=text-align:center>LA32</td>
<td style=text-align:center><code>add.d</code></td>
<td style=text-align:center>❌</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:center>LA64</td>
<td style=text-align:center><code>add.w</code></td>
<td style=text-align:center>⭕</td>
<td>32-bit addition</td>
</tr>
<tr>
<td style=text-align:center>LA64</td>
<td style=text-align:center><code>add.d</code></td>
<td style=text-align:center>⭕</td>
<td>64-bit addition</td>
</tr>
</tbody>
</table>
<p>Compare this with the RISC-V approach: still using additions for our example,
the <code>add</code> instruction always operates on native (XLEN) width operands,
representing the 32-bit addition on RV32 cores, and 64-bit addition on RV64
cores.
Meanwhile, the <code>addw</code> instruction brought by RV64 only operates on the lower
32-bit even on RV64 cores, but this instruction does not exist on RV32 cores.</p>
<table>
<thead>
<tr>
<th style=text-align:center>Μarch/Machine mode</th>
<th style=text-align:center>Instruction</th>
<th style=text-align:center>Legal?</th>
<th>Operation represented</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>RV32</td>
<td style=text-align:center><code>addw</code></td>
<td style=text-align:center>❌</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:center>RV32</td>
<td style=text-align:center><code>add</code></td>
<td style=text-align:center>⭕</td>
<td>Native-width addition (XLEN=32)</td>
</tr>
<tr>
<td style=text-align:center>RV64</td>
<td style=text-align:center><code>addw</code></td>
<td style=text-align:center>⭕</td>
<td>32-bit addition</td>
</tr>
<tr>
<td style=text-align:center>RV64</td>
<td style=text-align:center><code>add</code></td>
<td style=text-align:center>⭕</td>
<td>Native-width addition (XLEN=64)</td>
</tr>
</tbody>
</table>
<p>(Trivia: this is one of the biggest mistakes your author made, while
<a href=https://github.com/loongson-community/docs/tree/master/unofficial/loongarch>reverse-engineering LoongArch from scratch</a>
before Loongson released the ISA manual &ndash; assuming that LoongArch specified
its operand widths just like RISC-V. 😂)</p>
<h3 id=how-many-instruction-formats-do-loongarch-have>How many instruction formats do LoongArch have?<a hidden class=anchor aria-hidden=true href=#how-many-instruction-formats-do-loongarch-have>#</a></h3>
<h4 id=tldr>tl;dr<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h4>
<p>There are 9 <em>typical</em> instruction formats.
But in fact there are <em>39</em>, based on real effort needed in porting low-level software.</p>
<h4 id=loongsons-official-stance>Loongson&rsquo;s &ldquo;official&rdquo; stance<a hidden class=anchor aria-hidden=true href=#loongsons-official-stance>#</a></h4>
<p>According to <em>LoongArch Reference Manual, Volume 1</em>, there are 9 <em>typical</em> instruction formats.</p>
<table>
<thead>
<tr>
<th style=text-align:center>No immediate</th>
<th style=text-align:center>With immediate</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>2R</td>
<td style=text-align:center>2RI8</td>
</tr>
<tr>
<td style=text-align:center>3R</td>
<td style=text-align:center>2RI12</td>
</tr>
<tr>
<td style=text-align:center>4R</td>
<td style=text-align:center>2RI14</td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>2RI16</td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>1RI21</td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>I26</td>
</tr>
</tbody>
</table>
<p>Which look like this when pictured:</p>
<style>.loongarch-insn-formats{table-layout:fixed!important;font-family:fira code,inziu iosevka,source code pro,menlo,consolas,monospace}.loongarch-insn-formats th,.loongarch-insn-formats td{min-width:1rem!important;padding:.1rem!important;border:1px solid var(--border);text-align:center!important}.loongarch-insn-formats th{background-color:var(--code-bg)}.loongarch-insn-formats th:first-child,.loongarch-insn-formats tbody td:first-child{background-color:var(--code-bg)}.loongarch-insn-formats td{font-size:14px}.loongarch-insn-formats .field-opcode{background-color:var(--code-bg)}</style>
<table class=loongarch-insn-formats>
<thead>
<tr>
<th rowspan=2>Format</th>
<th colspan=32>Instruction word</th>
</tr>
<tr>
<th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th>
<th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th>
<th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th>
<th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th>
</tr>
</thead>
<tbody>
<tr><td>2R</td><td class=field-opcode colspan=22></td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>3R</td><td class=field-opcode colspan=17></td><td colspan=5>rk</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>4R</td><td class=field-opcode colspan=12></td><td colspan=5>ra</td><td colspan=5>rk</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>2RI8</td><td class=field-opcode colspan=14></td><td colspan=8>imm</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>2RI12</td><td class=field-opcode colspan=10></td><td colspan=12>imm</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>2RI14</td><td class=field-opcode colspan=8></td><td colspan=14>imm</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>2RI16</td><td class=field-opcode colspan=6></td><td colspan=16>imm</td><td colspan=5>rj</td><td colspan=5>rd</td></tr>
<tr><td>1RI21</td><td class=field-opcode colspan=6></td><td colspan=16>imm low</td><td colspan=5>rj</td><td colspan=5>imm high</td></tr>
<tr><td>I26</td><td class=field-opcode colspan=6></td><td colspan=16>imm low</td><td colspan=10>imm high</td></tr>
</tbody>
<tfoot>
<tr><td colspan=33>Note: cells with <code>this background</code> represent opcode bits.</td></tr>
</tfoot>
</table>
<blockquote>
<p>There are a few instructions whose encoding style is not completely
equivalent to these 9 typical instruction formats.
However, the number of such instructions is small and the instructions
change little, which will not be inconvenient for compiler developers.</p>
</blockquote>
<p>&ldquo;change little&rdquo; 😏</p>
<h4 id=the-truth>The truth<a hidden class=anchor aria-hidden=true href=#the-truth>#</a></h4>
<p>According to the answer above, in fact LoongArch has no <em>well-defined</em>
instruction formats or operand slots.
Although most instructions have reasonably consistent encodings, the few that
do require special encoding are encoded almost arbitrarily.</p>
<p>Indeed, people still have to define all the instruction format variants when
developing (dis-)assemblers, because the machine does not care which format is
&ldquo;more typical&rdquo; than others; different is different.
We can observe this phenomenon in most open-source projects with this kind of
low-level handling:</p>
<ul>
<li>binutils: <a href=https://github.com/bminor/binutils-gdb/blob/binutils-2_38/opcodes/mips-opc.c>MIPS</a>、<a href=https://github.com/bminor/binutils-gdb/blob/binutils-2_38/opcodes/riscv-opc.c>RISC-V</a>、<a href=https://github.com/bminor/binutils-gdb/blob/binutils-2_38/opcodes/sparc-opc.c>SPARC</a>; there may or may not be definitions for the different instruction formats, but there are always complete description for operand slots.</li>
<li>LLVM: <a href=https://github.com/llvm/llvm-project/blob/llvmorg-13.0.0/llvm/lib/Target/Mips/MipsInstrFormats.td>MIPS</a>、<a href=https://github.com/llvm/llvm-project/blob/llvmorg-13.0.0/llvm/lib/Target/RISCV/RISCVInstrFormats.td>RISC-V</a>; significantly more instruction formats defined than the few &ldquo;basic formats&rdquo; described on manuals.</li>
<li>QEMU: <a href=https://gitlab.com/qemu-project/qemu/-/blob/v6.2.0/target/hppa/insns.decode>HPPA</a>、<a href=https://gitlab.com/qemu-project/qemu/-/blob/v6.2.0/target/riscv/insn32.decode>RISC-V</a>; ditto.</li>
</ul>
<p>If we classify the instruction formats according to the strict rule of
&ldquo;different bit-fields or different operand types, different format&rdquo;, then
<em>the v1.00 LoongArch base ISA has a total of 39 distinct instruction formats</em>.
The community-maintained <a href=https://github.com/loongson-community/loongarch-opcodes>loongarch-opcodes</a> project
provides a collection of all publicly known LoongArch instructions, and a
precise naming scheme for instruction formats.
(Disclaimer: your author is the maintainer of this project.)</p>
<p>Here are the 39 precisely defined LoongArch instruction formats
(consult the <a href=https://github.com/loongson-community/loongarch-opcodes>loongarch-opcodes documentation</a> for meanings of the operand slot names):</p>
<table class=loongarch-insn-formats>
<thead>
<tr>
<th rowspan=2>Format</th>
<th colspan=32>Instruction word</th>
</tr>
<tr>
<th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th>
<th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th>
<th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th>
<th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th>
</tr>
</thead>
<tbody>
<tr><td>CdFj</td><td class=field-opcode colspan=22></td><td colspan=5>Fj</td><td class=field-opcode colspan=2></td><td colspan=3>Cd</td></tr>
<tr><td>CdFjFk</td><td class=field-opcode colspan=17></td><td colspan=5>Fk</td><td colspan=5>Fj</td><td class=field-opcode colspan=2></td><td colspan=3>Cd</td></tr>
<tr><td>CdJ</td><td class=field-opcode colspan=22></td><td colspan=5>J</td><td class=field-opcode colspan=2></td><td colspan=3>Cd</td></tr>
<tr><td>CjSd5k16</td><td class=field-opcode colspan=6></td><td colspan=16>Sd5k16 low</td><td class=field-opcode colspan=2></td><td colspan=3>Cj</td><td colspan=5>Sd5k16 high</td></tr>
<tr><td>DCj</td><td class=field-opcode colspan=24></td><td colspan=3>Cj</td><td colspan=5>D</td></tr>
<tr><td>DFj</td><td class=field-opcode colspan=22></td><td colspan=5>Fj</td><td colspan=5>D</td></tr>
<tr><td>DJ</td><td class=field-opcode colspan=22></td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJK</td><td class=field-opcode colspan=17></td><td colspan=5>K</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJKUa2</td><td class=field-opcode colspan=15></td><td colspan=2>Ua2</td><td colspan=5>K</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJKUa3</td><td class=field-opcode colspan=14></td><td colspan=3>Ua3</td><td colspan=5>K</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJSk12</td><td class=field-opcode colspan=10></td><td colspan=12>Sk12</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJSk14</td><td class=field-opcode colspan=8></td><td colspan=14>Sk14</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJSk16</td><td class=field-opcode colspan=6></td><td colspan=16>Sk16</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk12</td><td class=field-opcode colspan=10></td><td colspan=12>Uk12</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk14</td><td class=field-opcode colspan=8></td><td colspan=14>Uk14</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk5</td><td class=field-opcode colspan=17></td><td colspan=5>Uk5</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk5Um5</td><td class=field-opcode colspan=11></td><td colspan=5>Um5</td><td class=field-opcode colspan=1></td><td colspan=5>Uk5</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk6</td><td class=field-opcode colspan=16></td><td colspan=6>Uk6</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk6Um6</td><td class=field-opcode colspan=10></td><td colspan=6>Um6</td><td colspan=6>Uk6</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DJUk8</td><td class=field-opcode colspan=14></td><td colspan=8>Uk8</td><td colspan=5>J</td><td colspan=5>D</td></tr>
<tr><td>DSj20</td><td class=field-opcode colspan=7></td><td colspan=20>Sj20</td><td colspan=5>D</td></tr>
<tr><td>DUj5</td><td class=field-opcode colspan=22></td><td colspan=5>Uj5</td><td colspan=5>D</td></tr>
<tr><td>EMPTY</td><td class=field-opcode colspan=32></td></tr>
<tr><td>FdCj</td><td class=field-opcode colspan=24></td><td colspan=3>Cj</td><td colspan=5>Fd</td></tr>
<tr><td>FdFj</td><td class=field-opcode colspan=22></td><td colspan=5>Fj</td><td colspan=5>Fd</td></tr>
<tr><td>FdFjFk</td><td class=field-opcode colspan=17></td><td colspan=5>Fk</td><td colspan=5>Fj</td><td colspan=5>Fd</td></tr>
<tr><td>FdFjFkCa</td><td class=field-opcode colspan=14></td><td colspan=3>Ca</td><td colspan=5>Fk</td><td colspan=5>Fj</td><td colspan=5>Fd</td></tr>
<tr><td>FdFjFkFa</td><td class=field-opcode colspan=12></td><td colspan=5>Fa</td><td colspan=5>Fk</td><td colspan=5>Fj</td><td colspan=5>Fd</td></tr>
<tr><td>FdJ</td><td class=field-opcode colspan=22></td><td colspan=5>J</td><td colspan=5>Fd</td></tr>
<tr><td>FdJK</td><td class=field-opcode colspan=17></td><td colspan=5>K</td><td colspan=5>J</td><td colspan=5>Fd</td></tr>
<tr><td>FdJSk12</td><td class=field-opcode colspan=10></td><td colspan=12>Sk12</td><td colspan=5>J</td><td colspan=5>Fd</td></tr>
<tr><td>JK</td><td class=field-opcode colspan=17></td><td colspan=5>K</td><td colspan=5>J</td><td class=field-opcode colspan=5></td></tr>
<tr><td>JKUd5</td><td class=field-opcode colspan=17></td><td colspan=5>K</td><td colspan=5>J</td><td colspan=5>Ud5</td></tr>
<tr><td>JSd5k16</td><td class=field-opcode colspan=6></td><td colspan=16>Sd5k16 low</td><td colspan=5>J</td><td colspan=5>Sd5k16 high</td></tr>
<tr><td>JUd5</td><td class=field-opcode colspan=22></td><td colspan=5>J</td><td colspan=5>Ud5</td></tr>
<tr><td>JUd5Sk12</td><td class=field-opcode colspan=10></td><td colspan=12>Sk12</td><td colspan=5>J</td><td colspan=5>Ud5</td></tr>
<tr><td>JUk8</td><td class=field-opcode colspan=14></td><td colspan=8>Uk8</td><td colspan=5>J</td><td class=field-opcode colspan=5></td></tr>
<tr><td>Sd10k16</td><td class=field-opcode colspan=6></td><td colspan=16>Sd10k16 low</td><td colspan=10>Sd10k16 high</td></tr>
<tr><td>Ud15</td><td class=field-opcode colspan=17></td><td colspan=15>Ud15</td></tr>
</tbody>
<tfoot>
<tr><td colspan=33>Note: cells with <code>this background</code> represent opcode bits.</td></tr>
</tfoot>
</table>
<p>As is shown, LoongArch actually has vastly more complex encodings than MIPS or
RISC-V, both of which have about 20 distinct formats at most.
Although some of the LoongArch formats are definitely mergeable (for example
the FdCj and CdFj formats; they are the same if we do not pursue complete
correspondence of operand order in assembler syntax), that ship has sailed;
also the current scheme does conserve a lot of encoding space after all.</p>
<h3 id=is-the-la464-µarch-the-same-thing-as-gs464v-why-did-it-get-renamed>Is the LA464 µarch the same thing as GS464V? Why did it get renamed?<a hidden class=anchor aria-hidden=true href=#is-the-la464-µarch-the-same-thing-as-gs464v-why-did-it-get-renamed>#</a></h3>
<p><em>This answer contains speculations.</em></p>
<p>Frankly speaking, the Loongson Corporation does not really put any special
consideration in naming its micro-architectures or cores.
For example, the 3A4000 processor contains 4 GS464V cores, but the cores of
the much earlier 3B1500 are also called GS464V in the documentation.</p>
<blockquote>
<p>Author&rsquo;s comment:
There is the GS464EV name on <a href=https://en.wikipedia.org/wiki/Loongson>Wikipedia</a>, and it is coined
by the community exactly because of the desire to avoid ambiguity.
The µarch of 3A2000/3A3000 is called GS464E; 3A4000, as a &ldquo;tock&rdquo;/µarch
iteration, finally gained usable vector support by implementing MSA,
hence the GS464EV name.</p>
<p>(The former vector instructions developed in-house are lacking in terms of
functionality and documentation, so this is why we call MSA &ldquo;usable&rdquo;.)</p>
</blockquote>
<p>As for the LA464/GA464V, there are expressions like
&ldquo;adjusting ISA of present IP cores&rdquo; (“调整现有 IP 核的指令系统”)
that can be seen in earlier public articles or presentations about the
development of the 3A5000 or the LoongArch,
e.g. <a href=https://www.bilibili.com/video/BV1BK411T7Za>the August 2020 keynote by HU Weiwu</a>.
Considering that the 3A4000 and 3A5000 belong to the same tock-tick iteration,
such wording may imply that the 3A5000 is just the 3A4000 with a replaced
decoder.
However, it is not okay to re-use the codename, as the instruction set is
incompatible after all; the Loongson Corporation ultimately chose to modify
all of its documentation and open-source code to mass-replace GS464V with LA464
for the new LoongArch model, on August 2021.</p>
<p>So, overall it is more appropriate to consider the LA464 and GS464V as a
not-so-similar &ldquo;pair of twins&rdquo;, with roughly the same micro-architecture, but
different supported ISA.</p>
<h3 id=whats-the-relationship-between-loongarch-and-mips>What&rsquo;s the relationship between LoongArch and MIPS?<a hidden class=anchor aria-hidden=true href=#whats-the-relationship-between-loongarch-and-mips>#</a></h3>
<p>(Please note that all RISC architectures bear a significant resemblance to
each other, because all of them are made to perform the same thing called
&ldquo;general-purpose computation&rdquo;.)</p>
<p>According to public sources, LoongArch and MIPS cannot interoperate, and there
is no 1:1 correspondence between some of the important architectural features;
though such correspondence exists for many of their instruction semantics.</p>
<ul>
<li>LoongArch has entirely different instruction encoding than MIPS.</li>
<li>LoongArch does not have any form of branch delay slots, while MIPS did not
gain optional delay-slot-less branches/jumps until R6.</li>
<li>LoongArch does not feature some of the historical warts of MIPS, for example
the &ldquo;wonderful&rdquo; HI/LO accumulators.</li>
<li>LoongArch&rsquo;s ABI is based on that of RISC-V, departing from the MIPS
tradition. Concepts such as dedicated return value registers and registers
reserved for kernel use are abolished.</li>
</ul>
<p>However, there is objective MIPS influence on LoongArch. For example:</p>
<ul>
<li>LoongArch uses predicate registers <code>$fccX</code> for floating-point comparison and
branches, which are 8 distinct flag bits; this is the same as MIPS, and
rarely seen on other modern architectures.</li>
<li>LoongArch&rsquo;s privileged architecture is similar to that of MIPS. For example,
the LoongArch TLB has a special even/odd entry distinction; this is
cumbersome, hence not seen on any other prominent architecture but MIPS.</li>
<li>Some instructions have identical semantics as their MIPS R6 counterparts,
while similar semantically-identical instructions are not found in any other
prominent architecture.
The LoongArch <code>maskeqz/masknez</code> and the MIPS R6 <code>selnez/seleqz</code> are such an
example.</li>
<li>The way some operations are implemented are similar to MIPS R6, only with
minor changes.
For example, 64-bit immediates are materialized in 4 segments, and the 4
instructions used are <code>lu12i.w/ori/lu32i.d/lu52i.d</code> for LoongArch (here
using official mnemonics).
They only differ from their MIPS R6 counterparts (<code>lui/ori/dahi/dati</code>) in
the length of each segment: for LoongArch it is <code>12/20/20/12</code>, while for
MIPS it is <code>16/16/16/16</code>.
Also, this particular way of materializing immediates is not seen on any
other prominent architecture.</li>
<li>The Loongson Virtualization Extension is abbreviated as LVZ which is
extremely dubious.
Because &ldquo;Loongson SIMD Extension&rdquo; is LSX, &ldquo;Loongson Advanced SIMD Extension&rdquo;
is LASX and &ldquo;Loongson Binary Translation Extension&rdquo; is LBT (asymmetry here;
it should have been called LBTX), the virtualization extension should be
abbreviated LVX or LV; in no way it is conformant to pick two letters from
the second word to get LVZ. VZ is MIPS&rsquo;s name for its virtualization ASE!</li>
<li>The LoongArch assembler syntax is similar to that of MIPS.
Parentheses around memory operands are removed, but registers still have to
carry a <code>$</code> prefix, and pseudo-instructions such as <code>move</code> are named after
the MIPS counterparts, different from RISC-V etc.</li>
<li>Early LoongArch ports of fundamental software such as the toolchain or the
Linux kernel are basically just copy-pastes of MIPS code, mass-replacing
&ldquo;MIPS&rdquo; with &ldquo;LOONGARCH&rdquo; along the way.
(Of course, because the quality of such code is bound to be low, and the two
architectures are not <em>that</em> similar after all, the Loongson Corporation
stopped doing this not before long.)</li>
</ul>
<h3 id=whats-the-relationship-between-loongarch-and-risc-v>What&rsquo;s the relationship between LoongArch and RISC-V?<a hidden class=anchor aria-hidden=true href=#whats-the-relationship-between-loongarch-and-risc-v>#</a></h3>
<p>(Please note that all RISC architectures bear a significant resemblance to
each other, because all of them are made to perform the same thing called
&ldquo;general-purpose computation&rdquo;.)</p>
<p>According to public sources, LoongArch and RISC-V cannot interoperate, and
there is no 1:1 correspondence between some of the important architectural
features; though such correspondence exists for many of their instruction
semantics if certain conditions are met (restricted to 64-bit operation, for
example).</p>
<ul>
<li>LoongArch&rsquo;s privileged architecture and memory management are significantly
different to those of RISC-V.</li>
<li>The supported operations of LoongArch base ISA are mostly a superset of its
RISC-V counterpart.</li>
<li>RISC-V always sign-extends its immediate operands, while LoongArch
differentiates based on type of operation (sign-extending for arithmetic
operations; zero-extending for logical operations).</li>
<li>LoongArch has opcodes starting from MSB, precluding compressed instruction
words in the RVC way.</li>
</ul>
<p>There is significant RISC-V influence in the software part of LoongArch, such
as the ABI and several fundamental toolchain pieces.
LoongArch&rsquo;s ABI is rather similar to RISC-V&rsquo;s, and the semantic similarities
of instructions are notable as well.
Often, simple syntactic tweaks to the RISC-V version are all it takes to port
a primitive to LoongArch for some fundamental software.</p>
<p>Some LoongArch instructions have identical semantics as their RISC-V
counterparts; some of the architectural features are similar as well.
For example:</p>
<ul>
<li>The PIC-related <code>pcaddu12i</code> behaves the same as the RISC-V <code>auipc</code>.</li>
<li>The register jump <code>jirl</code> behaves the same as the RISC-V <code>jalr</code>,
very unlike the MIPS <code>jalr</code>.</li>
<li>The timekeeping instructions <code>rdtime.*</code> are semantically similar to their
RISC-V counterparts in that they all return values from a constant-frequency
counter.</li>
<li>LoongArch&rsquo;s privileged resources live in the CSR space, and the CSR concept
obviously comes from RISC-V. This is already the case back to 3A5000&rsquo;s
predecessor, 3A4000.</li>
<li>RISC-V originally defined 4 privilege levels (from high to low,
Machine/Hypervisor/Supervisor/User; Hypervisor was later removed), and
LoongArch defines 4 too (from high to low, PLV0/PLV1/PLV2/PLV3).
However, LoongArch OSes run at the highest level of PLV0, while it is
recommended for RISC-V OSes to run at the Supervisor level.</li>
</ul>
<p>And these are possible influences of RISC-V to LoongArch as well.</p>
<h3 id=how-many-abis-do-loongarch-have>How many ABIs do LoongArch have?<a hidden class=anchor aria-hidden=true href=#how-many-abis-do-loongarch-have>#</a></h3>
<p>LoongArch currently defines 3x2=6 ABIs, according to <a href=https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>the LoongArch ELF psABI</a>.</p>
<p><a href=https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models>Data models</a> of which are:</p>
<ul>
<li>ILP32 (<code>int</code>, <code>long</code> and pointers are 32-bit wide; a 32-bit model but not completely excluding 64-bit operations)</li>
<li>LP64 (<code>long</code> and wider types and pointers are 64-bit wide; this is the most common 64-bit data model in Linux space)</li>
</ul>
<p>And the floating-point support are:</p>
<ul>
<li>Soft-float (S)</li>
<li>Single-precision hard-float (F)</li>
<li>Double-precision hard-float (D)</li>
</ul>
<p>Currently only the LP64D ABI is fully supported.
All publicly available commercial distributions for LoongArch are built with
this ABI.
If you attempt to use the other ABIs, you are very likely to get all kinds of
compilation errors, so usage of these ABIs is not recommended at this early
stage of bring-up.
In particular, the support for the ILP32 ABIs are known to be very incomplete,
and it is extremely likely that builds will just error out immediately if one
ever try.</p>
<h3 id=what-happened-to-loongarchs-vector-extension>What happened to LoongArch&rsquo;s vector extension?<a hidden class=anchor aria-hidden=true href=#what-happened-to-loongarchs-vector-extension>#</a></h3>
<p><em>This answer is speculative because the relevant documentation has not been released.</em></p>
<p>The 3A4000 from the end of Loongson&rsquo;s MIPS era contains a complete implementation
of MIPS&rsquo;s MSA vector extension.
In addition to that, the 3A4000 also has support for the LoongMMI which is
inherited from the 2F era, and the LSX/LASX that never appeared in public
documentation.
Let&rsquo;s summarize all these vector extensions:</p>
<ul>
<li>MSA: 128-bit fixed vector width, according to <a href=https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00868-1D-MSA64-AFP-01.12.pdf>the MSA64 documentation v1.12</a>.</li>
<li>LoongMMI: usage extremely similar to the x86 MMX; 64-bit fixed vector width.</li>
<li>LSX/LASX: public information nearly non-existent aside from a few PPT slides,
open-source toolchain code only briefly and quietly appearing before being
redacted.
LSX should have a fixed vector length of 128-bit, while LASX should have 256.</li>
</ul>
<p>As can be seen, all the implemented vector instructions operate on fixed
vector lengths.
Taking the description of the <code>LSX</code> and <code>LASX</code> bits in the
<em>LoongArch Reference Manual, Volume 1</em>, Section 2.2.10.5 Table 3
&ldquo;The configuration information accessible by the CPUCFG instruction&rdquo;
into consideration
(&ldquo;128-bit vector extension&rdquo; and &ldquo;256-bit vector extension&rdquo; respectively),
it is presumed that LoongArch&rsquo;s LSX/LASX are similar to the LSX/LASX from the
MIPS era; at least the vector width should be fixed as well.
The instruction encodings must have been changed, and some instructions may
get added or removed as well;
there is no public documentation and open-source support after all,
so no external code makes use of these,
and compatibility is not a concern in this case.</p>
<p>Note that novel vector extensions in the recent years are all scalable, such
as the AArch64 SVE and the RISC-V RVV:
software is able to dynamically configure the vector unit to pick the vector
width most suitable to the requirement at hand, also meaning software does not
need to be modified to take advantage of wider hardware implementations.
This is generally a welcomed trend,
and we noticed <a href=https://github.com/loongson/glibc/commit/02cae44d5f05a06cba72458cf33d4a21b3813e3c>a change preparing for scalable vectors</a>
in Loongson&rsquo;s glibc fork.
Considering there may be multiple reasons for not releasing the LSX/LASX to
the public (especially IP concerns), this might mean that LSX/LASX would never
become public, and that a scalable vector implementation similar to RVV would
be available at some future time.</p>
<h3 id=what-happened-to-loongarchs-binary-translation-extension>What happened to LoongArch&rsquo;s binary translation extension?<a hidden class=anchor aria-hidden=true href=#what-happened-to-loongarchs-binary-translation-extension>#</a></h3>
<p><em>This answer is speculative because the relevant documentation has not been released.</em></p>
<p>Similar to the case of vector extension, we can speculate based on the binary
translation extension from the MIPS era.
Although there is no public instruction encodings nor kernel support, we
actually already had a sneak peek at the extension,
by means of some <a href=https://www.slideshare.net/syuu1228/hardware-assited-x86-emulation-on-godson-3-5040660>academic report</a>
or public presentations done by Loongson themselves
(<a href=https://www.bilibili.com/video/BV1BK411T7Za>the August 2020 keynote by HU Weiwu</a>,
<a href=https://www.bilibili.com/video/BV1KZ4y1c7kQ>the April 2021 presentation by ZHANG Fuxin</a>):</p>
<ul>
<li>New architectural state of the EFLAGS register is added, along with
purely EFLAGS-updating counterparts for some basic instructions;</li>
<li>New architectural state of the TOP register is added, along with the
corresponding FPU mode bit; semantics of FP register operands is altered to
be TOP-based if the x87 emulation mode is enabled.</li>
</ul>
<p>Loongson later added support for other operations too, such as the ARM
conditional execution, and the approach should be similar.
So, the x86 and ARM translation aid of LoongArch is likely to be minor tweaks
to the previous binary translation extension.
As for the translation of MIPS, because both MIPS and LoongArch are classical
RISC designs, branch delay slots may be the only hardware aid.
(Other weird MIPS features such as HI/LO registers are easily implemented in
software at translation time, because you have to recover the data flow
regardless.)</p>
<h2 id=about-software-development>About software development<a hidden class=anchor aria-hidden=true href=#about-software-development>#</a></h2>
<h3 id=im-going-to-port-my-software-to-loongarch-what-do-i-need-to-prepare-for>I&rsquo;m going to port my software to LoongArch. What do I need to prepare for?<a hidden class=anchor aria-hidden=true href=#im-going-to-port-my-software-to-loongarch-what-do-i-need-to-prepare-for>#</a></h3>
<p><strong>You don&rsquo;t have to specially prepare for anything!</strong></p>
<p>The expectation is for LoongArch to become a &ldquo;normal&rdquo; platform for software
and hardware development.
You just do on LoongArch whatever you used to do for other platforms, such as
x86 or ARM, except for those things inherently platform-specific.</p>
<p>If you develop for some specific domain with high-level programming languages,
you almost never need to care about low-level technical details of the platform.
These kind of things are already taken care of by the open-source community,
consisting of all enterprise and individual developers using Loongson.</p>
<p>If you are an infrastruture developer yourself, or a higher-level developer
that occasionally needs to care about low-level details here and there,
<a href=https://loongson.github.io/LoongArch-Documentation>the LoongArch documentation</a> provided by the
Loongson Corporation is a good starting point.</p>
<h3 id=how-do-i-quickly-familiarize-myself-with-loongarch-assembly>How do I quickly familiarize myself with LoongArch assembly?<a hidden class=anchor aria-hidden=true href=#how-do-i-quickly-familiarize-myself-with-loongarch-assembly>#</a></h3>
<p>The manual and ABI spec are your friends 😉</p>
<p>Syntactically, LoongArch&rsquo;s assembly language is basically a simplified version
of MIPS assembly, but there are a few important differences as well.
Based on personal experiences,
it is easy to quickly on-board oneself by &ldquo;thinking in RISC-V while writing MIPS&rdquo;;
this, coupled with manual reading, it is easy to master the language as well.</p>
<ul>
<li>Registers must be prefixed with <code>$</code>, like MIPS.
(In RISC-V assembly this is not necessary.)</li>
<li>The ABI divides registers into three classes <code>$a*</code> <code>$t*</code> <code>$s*</code>, like RISC-V.
(Different from MIPS; there is no distinct <code>$v*</code> nor <code>$k*</code>.)</li>
<li>The way of doing PIC is the same as RISC-V, different from MIPS.
(The abicall convention is a compromise to the limited functionality of the
pre-R6 MIPS ISA, and as such, there is no point carrying it over to the new
era.)</li>
<li>The way of doing TLS (Thread-local storage) is the same as RISC-V.
(Different from MIPS; LoongArch has the dedicated <code>$tp</code> register so it is no
longer necessary to workaround this with things like <code>rdhwr</code>.)</li>
<li>The register move pseudo-instruction is called <code>move</code>, like MIPS.
(Different from x86 or RISC-V; <code>mov</code> or <code>mv</code> are not recognized.)</li>
<li>The no-op is spelled <code>nop</code> as with most architectures.
(Syntactic sugar for <code>andi $zero, $zero, 0</code>.)</li>
<li>Return from subroutine is <code>jr $ra</code>, like MIPS.
(Syntactic sugar for <code>jirl $zero, $ra, 0</code>; different from RISC-V, there is
no <code>ret</code> as an additional syntactic sugar as of 2022-02-13.)</li>
<li>Different from MIPS, there are no parentheses around registers that represent
memory operands.
(<code>ld $a0, 16($a1)</code> becomes <code>ld.d $a0, $a1, 16</code>.)</li>
<li>A width suffix is needed for the <code>li</code> pseudo-instruction as well.
(<code>li.w</code> suffices most of the time; it is seldom necessary to load 64-bit
constants.)</li>
<li>As for operand ordering of instructions, most follow the rule of registers
before immediates, and from LSB to MSB in each group.
Note that there are exceptions if using manual syntax!</li>
</ul>
<p>Aside from these, there are some known inconsistent, misleading or even
errorneous descriptions existing in the current version (v1.00) of the ISA
manual, due to Loongson not soliciting reviews from the wider community before
publishing the manuals.
These are all described in the <a href=https://github.com/loongson-community/loongarch-opcodes>loongarch-opcodes</a> project&rsquo;s documentation.</p>
<blockquote>
<p>Author&rsquo;s comments:</p>
<p>The loongarch-opcodes review feedbacks are already sent back to relevant
teams at Loongson. But they replied with something like &ldquo;It&rsquo;s impossible to
modify the manuals like that now, after publication, in part also because
there&rsquo;s no precedent of any other company doing this such as Intel or ARM;
developers just have to take some more time to get accustomed&rdquo; 😏
As if developers inside Loongson actually had similar expertise as their
fellow Intel or ARM developers, and that everything is done correct in one
go.
Or do they?</p>
<p>Regardless, your author and other friends in support of the project are
still actively communicating and pushing every fix and improvement forward,
in hopes of eliminating as many warts as possible before LoongArch is known
to a wider audience. We do not want future developers to fall for the same
traps that we had already fallen into.</p>
</blockquote>
<h3 id=im-using-cc-how-do-i-specify-the-cflags-on-loongarch-how-to-conditionally-compile-for-loongarch-and-its-features>I&rsquo;m using C/C++. How do I specify the CFLAGS on LoongArch? How to conditionally compile for LoongArch and its features?<a hidden class=anchor aria-hidden=true href=#im-using-cc-how-do-i-specify-the-cflags-on-loongarch-how-to-conditionally-compile-for-loongarch-and-its-features>#</a></h3>
<p>Please consult <a href=https://loongson.github.io/LoongArch-Documentation/LoongArch-toolchain-conventions-EN.html>the LoongArch toolchain convention</a>.</p>
<h3 id=i-dont-have-loongarch-hardware-how-do-i-test-my-software-on-it-nevertheless>I don&rsquo;t have LoongArch hardware. How do I test my software on it nevertheless?<a hidden class=anchor aria-hidden=true href=#i-dont-have-loongarch-hardware-how-do-i-test-my-software-on-it-nevertheless>#</a></h3>
<p>You could use QEMU for this most of the time.
Both system emulation (emulating a complete LoongArch computer) and user-mode
emulation (emulating a LoongArch Linux syscall interface on top of the host
Linux kernel) are supported.
Usage of QEMU is outside the scope of this documentation; consult other online
resources for that.</p>
<p>Note: As of 2022-02-12, target support for LoongArch is not upstreamed yet.
This means you would have to compile
<a href=https://github.com/loongson/qemu/tree/tcg-dev>Loongson&rsquo;s development branch</a> yourself.</p>
<h2 id=about-the-loongarch-ecosystem>About the LoongArch ecosystem<a hidden class=anchor aria-hidden=true href=#about-the-loongarch-ecosystem>#</a></h2>
<h3 id=which-linux-distributions-have-been-ported-to-loongarch>Which Linux distributions have been ported to LoongArch?<a hidden class=anchor aria-hidden=true href=#which-linux-distributions-have-been-ported-to-loongarch>#</a></h3>
<p>Thanks to prioritized hardware access and team collaboration provided by the
Loongson Corporation, the commercial development around LoongArch is
progressing very rapidly.</p>
<p>As of 2022-02-12, multiple commercial distributions (developed by China
mainland entities) already provide LoongArch ports.
These include but are not limited to: (in alphabetical order)</p>
<ul>
<li>Kylin (from <a href=https://kylinos.cn>the Kylin Software Corporation</a>; website is Chinese-only)</li>
<li>Loongnix (from <a href=https://www.loongson.cn/>the Loongson Corporation</a>; website is Chinese-only)</li>
<li>UOS (from <a href=https://www.uniontech.com>the UnionTech Corporation</a>; website is Chinese-only)</li>
</ul>
<p><a href=http://www.loongnix.cn>Loongnix</a> claims to be the &ldquo;Linux OS from the Loongson
open-source community&rdquo;, but because there are actually very few external
participants if at all, and some of its packages are not open-source
(especially the toolchain; the current Loongnix LoongArch port even has vector
extension support!), this distribution is in effect a commercial one.</p>
<p>After the publication of the various LoongArch documentation, and
open-sourcing of Loongson forks of fundamental pieces of software,
the porting pace of community distributions has accelerated as well.</p>
<p>There are several ongoing porting efforts as of 2022-02-12, including but
not limited to: (in alphabetical order)</p>
<ul>
<li>Arch Linux</li>
<li>CLFS</li>
<li>Gentoo</li>
</ul>
<h3 id=why-cant-i-run-closed-source-software-like-wps-office-on-community-distributions-aka-whats-this-so-called-old-world-and-new-world>Why can&rsquo;t I run closed-source software like WPS Office on community distributions? (aka What&rsquo;s this so-called &ldquo;old world&rdquo; and &ldquo;new world&rdquo;?)<a hidden class=anchor aria-hidden=true href=#why-cant-i-run-closed-source-software-like-wps-office-on-community-distributions-aka-whats-this-so-called-old-world-and-new-world>#</a></h3>
<p>As of 2022-02-12, all commercial LoongArch distributions are incompatible with
all community distributions.
All binary software built on community distributions, and some software
written in high-level languages and existing in forms like source code or
bytecode (such as those written in Python or Java) cannot run on commercial
distributions, and vice versa.
All closed-source software from ISVs such as WPS Office are built on
commercial distributions, so they are extremely unlikely to work as-is on
community distributions.</p>
<p>This is the so-called compatibility problem between the <em>old-world</em> and the <em>new-world</em>.
Because the Loongson Corporation finished all commercial moves before
announcing the LoongArch to the open-source community, the open-source
LoongArch ecosystem is <em>the new world</em>; in contrast to this, all commercial
distributions and the ecosystem associated make up <em>the old world</em>.
The two worlds are to be united eventually, but are two parallel universes for
now; and the technical difficulty of making the two worlds compatible with
each other is enormous.</p>
<p>As for the reason for two worlds and ways to be compatible, that is a long
story ;-)
Let&rsquo;s save this for another article, dedicated to the topic and to be written
shortly.</p>
<h3 id=what-loongarch-hardware-can-i-buy>What LoongArch hardware can I buy?<a hidden class=anchor aria-hidden=true href=#what-loongarch-hardware-can-i-buy>#</a></h3>
<p>Although international ways of purchasing Loongson products has largely died
out after the 2F era (when international marketing of Loongson products were
taken care of by STMicroelectronics),
at least in China mainland, you can easily get your hands on various products
with LoongArch CPUs, all of which are publicly available.
For example, there are ATX boards, prebuilt computers and notebooks with the
3A5000; and there are rack-mounted servers for the 3C5000L.</p>
<p>This document cannot provide any link to actual products or shops, due to your
author having no affiliation with them, but you can always search for &ldquo;龙芯&rdquo;
yourself on popular Chinese shopping sites like ○宝, ○东 or ○鱼 (you will know
the exact names if you have literally any clue about the Chinese language and
the Chinese Internet life in general, or just give this document to one of
your helpful Chinese friends 😆).</p>
<p>Note: the Loongson products are almost always significantly more expensive
than similarly specced &ldquo;mainstream&rdquo; x86 or ARM products, due to the small
production volume. On top of that, there are more fundamental problems for
the Loongson platform to solve at this early stage of development, so it is
<em>not</em> recommended for casual users to buy.</p>
<h3 id=how-can-i-get-acquainted-with-other-fellow-loongarch-fans>How can I get acquainted with other fellow LoongArch fans?<a hidden class=anchor aria-hidden=true href=#how-can-i-get-acquainted-with-other-fellow-loongarch-fans>#</a></h3>
<p>Communities exist for any technology with users, and LoongArch is no exception
(your author and his friends are not cats, after all).</p>
<p>There are a lot of places on the Internet where Loongson and LoongArch topics
are discussed. Some places frequented by many people are (but not limited to):</p>
<ul>
<li><a href=http://bbs.loongnix.cn/>Forum of the Loongson Open-source Community</a> (龙芯开源社区论坛) (HTTP-only due to technical reasons; Chinese-only)</li>
<li><a href="https://tieba.baidu.com/f?kw=%E9%BE%99%E8%8A%AF&ie=utf-8">Loongson Bar on Baidu Tieba</a> (百度贴吧龙芯吧) (Chinese-only)</li>
<li><a href=https://t.me/loongson_users>Telegram Loongson group</a>（Chinese & English）</li>
<li>QQ group 922566903 (Chinese-only)</li>
</ul>
<p>There may be other QQ groups discussing Loongson topics, but your author does
not use QQ so he does not know the number.
(PM and PRs are welcomed for suggesting more of them!)</p>
<p>Note that these public venues are better suited to general chatter, instead of
serious technical discussion.
Because some of the end-user fans take rather radical technical/political
positions, technical discussions may easily get derailed if any of the more
sensitive topics is inadvertently touched.
However, you should be able to find the appropriate place for communication
between developers if you possess the desired communication attitude and
ability; due to this, links to such places are left out for now. ;-)</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=next href=https://blog.xen0n.name/en/posts/old/meizu-mx4-cm/cm-12.1-userdebug-11/>
<span class=title>Next Page »</span>
<br>
<span>CyanogenMod for Meizu MX4: CM12.1 20160411 testing release</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>© WANG Xuerui; licensed with cc-by-nc-sa 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>